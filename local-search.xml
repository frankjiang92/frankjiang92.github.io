<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>开源推荐 | 如何一键安装MacOS虚拟机</title>
    <link href="/2021/008-macos-vm-install/"/>
    <url>/2021/008-macos-vm-install/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hi 大家好，我是「 毛与帆 」，一个热爱技术的后端工程师，感谢你的关注！</p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="欢迎关注我的公众号「 毛与帆 」"></p><p>最近逛GitHub发现了一个超级黑科技的项目，可以<strong>通过脚本在Windows电脑上一键安装MacOS虚拟机</strong>，如果你想入手一台Mac电脑，但又考虑到高昂的价格，你可以在Windows上安装MacOS来尝尝鲜，下来我们一起来看下吧。</p><p>这个开源项目就是<a href="https://github.com/myspaghetti/macos-virtualbox">macos-virtualbox</a>，GitHub的地址为：<code>https://github.com/myspaghetti/macos-virtualbox</code>，目前这个项目已经有<code>1.1w</code>的star，非常的受欢迎。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210907222428072.png" alt="项目主页"></p><p>下面我们来看一下如何在Windows电脑上安装MacOS虚拟机吧。</p><h2 id="1-需要哪些依赖？"><a href="#1-需要哪些依赖？" class="headerlink" title="1. 需要哪些依赖？"></a>1. 需要哪些依赖？</h2><p>首先，我们需要电脑满足如下条件才可以安装：</p><ul><li><strong>8GB以上的内存</strong></li><li><strong>磁盘空间至少50GB以上</strong></li><li><strong>安装VirtualBox 6.1.6 以上的版本</strong></li><li><strong>安装Cygwin工具，并安装所需要依赖</strong>：<code>bash</code> <code>coreutils</code> <code>gzip</code> <code>unzip</code> <code>wget</code> <code>xxd</code> <code>tesseract-ocr</code> 和 <code>tesseract-ocr-eng</code></li></ul><h2 id="2-开始安装MacOS虚拟机"><a href="#2-开始安装MacOS虚拟机" class="headerlink" title="2. 开始安装MacOS虚拟机"></a>2. 开始安装MacOS虚拟机</h2><h3 id="2-1-打开Cygwin64-Terminal工具"><a href="#2-1-打开Cygwin64-Terminal工具" class="headerlink" title="2.1 打开Cygwin64 Terminal工具"></a>2.1 打开<code>Cygwin64 Terminal</code>工具</h3><p>首先，我们找到<code>Cygwin64 Terminal</code>工具并打开它，这个是一个命令行工具，后面的操作基本都在这个命令行工具内就可以完成。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210907223137451.png" alt="打开Terminal"></p><h3 id="2-2-切换到我们需要安装的目录"><a href="#2-2-切换到我们需要安装的目录" class="headerlink" title="2.2 切换到我们需要安装的目录"></a>2.2 切换到我们需要安装的目录</h3><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210907223307319.png" alt="切换到目录"></p><h3 id="2-3-下载安装脚本"><a href="#2-3-下载安装脚本" class="headerlink" title="2.3 下载安装脚本"></a>2.3 下载安装脚本</h3><p>在命令行中下面的命令，下载脚本<code>macos-guest-virtualbox.sh</code></p><pre><code class="hljs bash">wget https://raw.githubusercontent.com/myspaghetti/macos-guest-virtualbox/master/macos-guest-virtualbox.sh</code></pre><h3 id="2-4-执行安装脚本"><a href="#2-4-执行安装脚本" class="headerlink" title="2.4 执行安装脚本"></a>2.4 执行安装脚本</h3><p>然后在命令行中执行如下命令：</p><pre><code class="hljs bash">./macos-guest-virtualbox.sh</code></pre><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210905151457769.png" alt="开始安装"></p><p>然后就可以开始安装了，你只需要再一些需要确认的地方敲击<code>回车键</code>进行确认，即可继续安装</p><p>安装过程耗时有比较长，因为脚本需要下载MacOS的安装镜像，等镜像下载完成，就会自动启动<code>VirtualBox</code>的虚拟机，我们可以在<code>VirtualBox</code>内看到虚拟机正在启动，如下图所示：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210907224000.png" alt="VirtualBox界面"></p><p>然后可以看到如下图所示的安装界面，只要静静的等待安装完成即可：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210905150220821.png" alt="安装界面"></p><p>最后安装完成后，在命令行中会看到<code>That&#39;s it! Enjoy you virtual machine</code>，表示虚拟机已经安装完成了。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210905151409819.png" alt="安装完成"></p><p>最后，你可以在VirtualBox中启动虚拟机，刚开始又有一些配置，按照系统的提示一步一步选择即可完成机器的创建。</p><h2 id="3-安装后的效果"><a href="#3-安装后的效果" class="headerlink" title="3. 安装后的效果"></a>3. 安装后的效果</h2><p>最后，放上几张我安装之后的效果给大家看一下，基本的功能使用都正常，使用起来还是比较流畅</p><p><img src="/2021/008-macos-vm-install/image-20210907225313022.png" alt="APP列表"></p><p><img src="/2021/008-macos-vm-install/image-20210907225214724.png" alt="xcode界面"></p><p><img src="/2021/008-macos-vm-install/image-20210907225548872.png" alt="APP Store界面"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>在上面的安装过程中，总体还是比较顺利的，并没有遇到难以解决的问题，所以这也是这个项目如此受欢迎的原因。</p><p>由于各个电脑硬件设备的不同，以及系统及软件的不同，安装虚拟机的过程可能会遇到一些问题，小伙伴们也可以在网上搜索问题原因并针对性的解决，也可以<strong>在后台给我留言</strong>，我们一起解决。</p><p>最后，希望可以体验MacOS的小伙伴，可以行动起来了！</p><p><strong>项目的GitHub地址</strong>：<code>https://github.com/myspaghetti/macos-virtualbox</code></p><hr><blockquote><p><strong>我是「 毛与帆 」，如果本文对你有帮助，欢迎向各位小伙伴点赞、评论和关注，感谢各位老铁，我们下期见</strong></p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="mp_white"></p>]]></content>
    
    
    <categories>
      
      <category>开源推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黑科技</tag>
      
      <tag>开源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java系列 | Java线程模型与volatile</title>
    <link href="/2021/007-java-memory-model/"/>
    <url>/2021/007-java-memory-model/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hi 大家好，我是「 毛与帆 」，一个热爱技术的后端工程师，感谢你的关注！</p></blockquote><p>在前两篇文章<a href="/2021/005-java-concurrency-basic/">深入理解Java系列 | 并发编程基础</a>和<a href="/2021/006-java-thread-basic/">深入理解Java系列 | 线程基础</a>，我们了解了并发编程以及线程的基础知识，那么本文我们继续聊一下Java的线程模型，以及volatile和synchronized的实现原理。</p><p>现在开始吧！</p><h1 id="1-Java线程模型"><a href="#1-Java线程模型" class="headerlink" title="1. Java线程模型"></a>1. Java线程模型</h1><h2 id="1-1-什么是Java线程模型"><a href="#1-1-什么是Java线程模型" class="headerlink" title="1.1 什么是Java线程模型"></a>1.1 什么是Java线程模型</h2><h2 id="1-2-Java线程模型解决了什么问题"><a href="#1-2-Java线程模型解决了什么问题" class="headerlink" title="1.2 Java线程模型解决了什么问题"></a>1.2 Java线程模型解决了什么问题</h2><h2 id="1-3-如何立即happens-before原则"><a href="#1-3-如何立即happens-before原则" class="headerlink" title="1.3 如何立即happens-before原则"></a>1.3 如何立即happens-before原则</h2><h1 id="2-深入理解volatile"><a href="#2-深入理解volatile" class="headerlink" title="2. 深入理解volatile"></a>2. 深入理解volatile</h1><h2 id="2-1-volatile的作用"><a href="#2-1-volatile的作用" class="headerlink" title="2.1 volatile的作用"></a>2.1 volatile的作用</h2><h2 id="2-2-volatile的实现原理"><a href="#2-2-volatile的实现原理" class="headerlink" title="2.2 volatile的实现原理"></a>2.2 volatile的实现原理</h2><h1 id="3-深入理解synchronized"><a href="#3-深入理解synchronized" class="headerlink" title="3. 深入理解synchronized"></a>3. 深入理解synchronized</h1><h2 id="3-1-synchronized的作用"><a href="#3-1-synchronized的作用" class="headerlink" title="3.1 synchronized的作用"></a>3.1 synchronized的作用</h2><h2 id="3-2-synchronized的原理"><a href="#3-2-synchronized的原理" class="headerlink" title="3.2 synchronized的原理"></a>3.2 synchronized的原理</h2><h2 id="3-3-深入理解锁膨胀"><a href="#3-3-深入理解锁膨胀" class="headerlink" title="3.3 深入理解锁膨胀"></a>3.3 深入理解锁膨胀</h2><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><hr><blockquote><p><strong>我是「 毛与帆 」，如果本文对你有帮助，欢迎向各位小伙伴点赞、评论和关注，感谢各位老铁，我们下期见</strong></p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="mp_white"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java系列 | 线程基础</title>
    <link href="/2021/006-java-thread-basic/"/>
    <url>/2021/006-java-thread-basic/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hi 大家好，我是「 毛与帆 」，一个热爱技术的后端工程师，感谢你的关注！</p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="欢迎关注我的公众号「 毛与帆 」"></p><p>在上一篇文章<a href="/2021/005-java-concurrency-basic/">深入理解Java系列 | 并发编程基础</a>中，我们主要整理了并发编程的基础知识以及三大核心问题，并了解了线程是并发编程的重要实现方式，所以本文我们主要来了解一下Java中线程的基础知识。</p><p>现在开始吧！</p><h1 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1. 什么是线程？"></a>1. 什么是线程？</h1><p>在上一篇文章<a href="/2021/005-java-concurrency-basic/">深入理解Java系列 | 并发编程基础</a>中我们已经知道：<strong>线程是进程的组成部分，一个进程至少有一个线程组成</strong>。一个进程中可以创建多个线程，每个线程拥有各自的计数器、堆栈和局部变量等属性，并且能够访问进程共享的内存变量。<strong>线程也是操作系统进行任务执行和调度的基本单位，操作系统可以控制多个线程之间交替运行，以实现并发执行的效果</strong>。</p><p><strong>为什么我们的程序需要多个线程呢？</strong></p><p>随着计算机处理器的发展，目前我们的计算机处理器都有多个核心；由于一个线程只能在一个处理器核心上运行，所以为了充分利用多个处理器核心的并行能力，我们希望每个处理器核心都可以运行一个线程，所以就需要程序能够支持多线程机制，否则一个程序只能在一个处理器上核心上执行，其他核心则处于空闲状态。</p><p>基于多线程机制，可以充分利用处理器资源，并提高程序的响应速度和处理能力，</p><p><strong>是否程序的最大线程数就等于处理器核心的数量？</strong></p><p>并不是的。首先CPU执行线程的过程，并不是一直运行某个线程，而是通过<strong>时间片轮转调度算法</strong>对不同的线程进行调度，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。</p><p>比如线程A会在CPU中只执行一个时间片的时间，然后挂起再切换到其他线程执行；等时间片再分配给线程A时，会进行状态的恢复并重新执行，这样也就完成了一次<strong>上下文切换</strong>。</p><p>由于每个线程单次执行的时间非常短，所以可以认为所有的线程是在同时执行的。基于这个机制，我们可以在程序中创建多于处理器核心的线程，这样也可以充分利用处理器资源。</p><h1 id="2-线程的用法"><a href="#2-线程的用法" class="headerlink" title="2. 线程的用法"></a>2. 线程的用法</h1><h2 id="1-1-如何运行一个线程"><a href="#1-1-如何运行一个线程" class="headerlink" title="1.1 如何运行一个线程"></a>1.1 如何运行一个线程</h2><p>首先，如果需要运行一个线程，我们必须先构建一个线程对象，线程类是<code>Thread</code>，对于一个线程来说，还必须执行该线程需要执行的任务，这个是通过<code>Runnable</code>接口来实现的，也就是一个线程是执行一个<code>Runnable</code>任务。</p><p>我们可以定义一个任务类<code>TaskRunnable</code>，并实现<code>Runnable</code>接口，在<code>run</code>方法中循环打印0~99的数字，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;      System.out.println(<span class="hljs-string">&quot;数字：&quot;</span> + i);    &#125;  &#125;&#125;</code></pre><p>然后我们可以定义线程对象<code>thread</code>，并创建<code>TaskRunnable</code>任务对象作为Thread构造方法的入参；然后设置线程的属性，比如<code>name</code>，<code>daemon</code>，<code>priority</code>等；最后调用线程的<code>start()</code>方法，完成线程的启动。代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TaskRunnable());  thread.setName(<span class="hljs-string">&quot;task-thread&quot;</span>);  thread.setDaemon(<span class="hljs-keyword">false</span>);  thread.setPriority(<span class="hljs-number">5</span>);  thread.start();&#125;</code></pre><p>线程启动后，相当于当前线程告诉虚拟机已经创建了一个线程，可以对该线程进行调度执行。到此我们就完成了一个线程的创建和启动。线程开始执行后，会调用<code>TaskRunnable</code>类中<code>run</code>方法的代码，执行打印字符串的任务，循环完成后线程执行完毕并销毁。</p><h2 id="1-2-线程的属性"><a href="#1-2-线程的属性" class="headerlink" title="1.2 线程的属性"></a>1.2 线程的属性</h2><p>在上面的例子中，我们可以看到线程的主要属性有如下几个：</p><ul><li><p><code>Runnable target</code>：这个是线程所要执行的任务对象，通过构造方法传入；在runnable对象的<code>run</code>方法中定义了对象所要执行的任务详情。</p></li><li><p><code>String name</code>：这个是线程的名称，可以自定义线程名称，如果不设置会生成默认的名称；</p></li><li><p><code>boolean daemon</code>：通过该字段来标识线程是否为<strong>守护线程</strong>，需要在调用<code>thread.start()</code>方法前设置daemon，否则会抛除异常。</p></li></ul><p>守护线程是指为其他线程服务的线程，在Java虚拟机中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。对守护线程来说，它可以自动结束自己的生命周期，而其他非守护线程不具备这个功能。</p><p><strong>守护线程</strong>的一个典型用法就是JVM中的垃圾回收线程，当JVM需要结束时，垃圾回收线程可以自动结束。所以通常来说，守护线程的主要功能是执行一些后台任务，且在JVM退出时可以自动关闭。另外，对于守护线程来说，不要持有任何资源的连接，否则在JVM退出时会无法正常释放连接而出现异常。</p><p>最后需要注意的是，一个守护线程中产生的线程默认是守护线程，在用户线程中产生的线程默认是用户线程。</p><ul><li><code>int priority</code>：线程的优先级，优先级范围为1~10，在构建线程的时候可以通过<code>setPriority(int)</code>方法来修改优先级，默认优先级为5，优先级高的线程分配时间片的数量要多余优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。</li></ul><p>但是线程优先级不作为程序线程正确调度的依赖，因为不同的操作系统在线程规划上设计不同，某些操作系统不会完全按照优先级的设定进行调度，甚至会忽略优先级的设定。</p><h2 id="1-3-如何查看程序的线程？"><a href="#1-3-如何查看程序的线程？" class="headerlink" title="1.3 如何查看程序的线程？"></a>1.3 如何查看程序的线程？</h2><p>如果我们想要看看自己程序当前运行了哪些线程以及线程的执行状态，我们可以使用<code>jdk</code>自带的命令行工具<code>jstack</code>来查看程序执行的线程。</p><p>使用<code>jstack -l &lt;进程ID&gt;</code>来查看这个进程的的所有线程状态，其中包括<strong>线程名称</strong>，<strong>线程编号</strong>，<strong>是否守护线程</strong>，<strong>线程优先级</strong>，<strong>线程状态</strong>，<strong>线程执行的堆栈</strong>，<strong>线程持有的锁</strong>等信息，通过这些信息我们可以分析一个进程的线程状态，并可以分析是否有死锁产生。</p><p>如下图所示则为一个程序的部分线程信息。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210904183300.png" alt="线程状态"></p><h1 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h1><p>上面我们了解了线程了定义以及基本使用方法，下面我们来介绍下线程的状态，以及各个状态之间的转换。</p><p>首先，Java中线程共有六大状态，分别为：</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><code>NEW</code></td><td><strong>初始状态</strong>，线程被创建，但未调用<code>start()</code>方法</td></tr><tr><td><code>RUNNABLE</code></td><td><strong>运行状态</strong>，Java线程将操作系统中的就绪和运行两种状态都称为运行态</td></tr><tr><td><code>BLOCKED</code></td><td><strong>阻塞状态</strong>，表示线程阻塞于锁</td></tr><tr><td><code>WAITING</code></td><td><strong>等待状态</strong>，线程进入等待，需要等待其他线程作出一些动作（唤醒或者中断）</td></tr><tr><td><code>TIME_WAITING</code></td><td><strong>超时等待状态</strong>，不同于WAITINIG，可以在指定时间内超时自行返回</td></tr><tr><td><code>TERMINATED</code></td><td><strong>终止状态</strong>，表示当前线程已经执行完毕</td></tr></tbody></table><p>下图为各个线程生命周期的各状态的转换图：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/09/image-20210904195950731.png" alt="线程生命周期"></p><p>首先，线程创建之后会进入<strong>初始状态</strong>，调用线程的start方法后则进入<strong>运行状态</strong>，然后JVM虚拟机会对线程进行规划，这里的运行状态包括了就绪和运行中两种状态，其中运行中表示线程被分配了时间片可以正常执行；当线程执行需要等待锁的获取时，则会进入到<strong>阻塞状态</strong>，直到获取锁成功会再进入运行状态；在线程运行状态时，可以主动休眠进入<strong>等待状态</strong>，在等待状态时该线程只能被其他线程唤醒才可以恢复到<strong>运行状态</strong>；或者可以设置等待时间进入<strong>超时等待状态</strong>，这时线程可以被其他线程唤醒，或者到达等待时间后自动被唤醒；当线程运行结束后，则进入<strong>终止状态</strong>，线程整个生命周期结束。</p><h1 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h1><p>在上一节的线程状态中，我们看到会有一些方法可以使线程的状态进行切换，比如<code>Object.wait()</code>方法、<code>Object.join()</code>方法等，线程之间进行通信就是基于这些方法来实现的，这是Java提供的<strong>等待/通知机制</strong>，基于这一机制，可以保证线程通信的及时性，以及降低等待过程的CPU开销。</p><p>本节我们主要介绍下<strong>等待/通知机制</strong>的具体用法。下面是等待/通知的主要方法：</p><ul><li><code>wait()</code>：调用该方法的线程将进入<code>WAITINIG</code>状态，只有等待其他线程的通知或者被中断才可以返回；当调用<code>wait</code>方法后，会释放对象的锁；</li><li><code>wait(long)</code>：超时等待一段时间，调用该方法后会进入<code>TIME_WAITING</code>状态，可以被其他线程唤醒，也可以在一定时间之后自动返回，超时时间的单位是毫秒；同样的，调用<code>wait(long)</code>方法后会释放对象的锁；</li><li><code>wait(long, int)</code>：与<code>wait(long)</code>方法功能相同，支持更细粒度的超时等待，最低可以支持纳秒；</li><li><code>notify()</code>：通知一个对象上等待的线程，使其从<code>wait()</code>方法返回，返回的前提是需要重新获取对象的锁；</li><li><code>notifyAll()</code>：与<code>notify</code>方法功能相同，通知所有等待在对象上的线程；</li><li><code>thread.join()</code>：等待thread线程终止后，当前线程才从join方法返回；</li><li><code>thread.join(long)</code>和<code>thread.join(long, int)</code>：与<code>join()</code>方法类似，支持设置等待线程thread执行的超时时间，当在超时时间内未执行完成也会从join方法返回。</li></ul><p>下面的示例展示了如何通过wait和notify进行线程间通信(代码参考自《并发编程的艺术》一书第4.3.2节)：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest2</span> </span>&#123;  <span class="hljs-keyword">static</span> Object lock = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread waitThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Wait(), <span class="hljs-string">&quot;WaitThread&quot;</span>);    waitThread.start();    sleep(<span class="hljs-number">1</span>);    Thread notifyThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Notify(), <span class="hljs-string">&quot;NotifyThread&quot;</span>);    notifyThread.start();  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wait</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">synchronized</span> (lock) &#123;        <span class="hljs-keyword">while</span> (flag) &#123;          <span class="hljs-comment">// 条件不满足，继续wait，同时释放lock的锁</span>          <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; flag is true, wait @ &quot;</span> + System.currentTimeMillis());            lock.wait();          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          &#125;        &#125;        <span class="hljs-comment">// 条件满足，完成工作</span>        System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; flag is false, running @ &quot;</span> + System.currentTimeMillis());      &#125;    &#125;  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Notify</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">synchronized</span> (lock) &#123;        System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; hold lock, notify @ &quot;</span> + System.currentTimeMillis());        lock.notifyAll();        flag = <span class="hljs-keyword">false</span>;        sleep(<span class="hljs-number">5</span>);      &#125;      <span class="hljs-keyword">synchronized</span> (lock) &#123;        System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; hold lock again, sleep @ &quot;</span> + System.currentTimeMillis());        sleep(<span class="hljs-number">5</span>);      &#125;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sec)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;      TimeUnit.SECONDS.sleep(sec);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;    &#125;  &#125;&#125;</code></pre><p>运行输出的结果如下：</p><pre><code class="hljs angelscript">Thread[WaitThread,<span class="hljs-number">5</span>,main] flag <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>, wait @ <span class="hljs-number">1630831336411</span>Thread[NotifyThread,<span class="hljs-number">5</span>,main] hold lock, notify @ <span class="hljs-number">1630831337415</span>Thread[NotifyThread,<span class="hljs-number">5</span>,main] hold lock again, sleep @ <span class="hljs-number">1630831342415</span>Thread[WaitThread,<span class="hljs-number">5</span>,main] flag <span class="hljs-keyword">is</span> <span class="hljs-literal">false</span>, running @ <span class="hljs-number">1630831347416</span></code></pre><p>在上面的代码中，首先<code>WaitThread</code>获取锁，然后判断<code>flag</code>为true，则调用<code>wait</code>方法进入等待，并释放锁；然后<code>NotifyThread</code>线程执行，并获取到锁，然后首先唤醒了等待的线程<code>WaitThread</code>，然后再修改<code>flag</code>标志为false，并sleep休眠5秒钟；由于在sleep时，线程并未释放锁，所以此时<code>WaitThread</code>虽然被唤醒但无法获取锁，所以不能从<code>wait</code>方法返回；等<code>NotifyThread</code>执行完成后会释放锁，此时<code>WaitThread</code>获取锁，并最终执行完成。</p><p>通过上面的例子，我们大概了解了两个线程如何进行交互通信，在使用<code>wait</code>、<code>notify</code>方法时，需要注意如下几个方面：</p><ul><li><code>wait</code>、<code>notify</code>和<code>notifyAll</code>方法调用时，需要先对调用的对象进行加锁；</li><li>调用<code>wait()</code>方法后，线程状态由<code>RUNNING</code>变为<code>WAITING</code>，并将该线程放置到对象的等待队列中；</li><li><code>notify</code>或者<code>notifyAll</code>方法调用后，等待线程不会立刻从<code>wait()</code>返回，需要等待调用<code>notify</code>的线程释放锁之后，等待的线程才有机会从<code>wait</code>返回；</li><li><code>notify</code>方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而<code>notifyAll</code>方法是将所有的等待队列中的线程移到同步队列；被移动的线程状态由<code>WAITING</code>变为<code>BLOCKED</code>；</li><li>从<code>wait</code>方法返回的前提是需要重新获得调用对象的锁。</li></ul><h1 id="4-线程间通信的主要模式"><a href="#4-线程间通信的主要模式" class="headerlink" title="4. 线程间通信的主要模式"></a>4. 线程间通信的主要模式</h1><p>从上面的<code>WaitThread</code>和<code>NotifyThread</code>的示例中可以了解到，其中一个线程(<code>WaitThread</code>)充当任务处理者，也就是消费者，另一个线程(<code>NotifyThread</code>)充当任务触发者，也就是生产者，两者之间可以基于<code>等待/通知机制</code>进行通信，来保证任务生产后立即有消费者处理，无任务时所有消费者等待。</p><p>对于消费者来说，主要实现流程为;</p><ul><li>获取对象的锁</li><li>如果条件不满足，则调用对象的<code>wait</code>方法进行等待；被唤醒后需要再次检查是否满足条件</li><li>条件满足则执行对应的处理逻辑</li></ul><p>伪代码实现为：</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(object) &#123;  <span class="hljs-keyword">while</span>(checkState()) &#123; <span class="hljs-comment">// 检查条件</span>    object.wait(); <span class="hljs-comment">// 加入等待队列</span>  &#125;  doSth(); <span class="hljs-comment">// 执行业务逻辑</span>&#125;</code></pre><p>对于生产者来说，主要实现流程为：</p><ul><li>获取对象的锁</li><li>改变条件：比如修改flag标识、往任务队列中插入任务等</li><li>通知所有等待在对象上的线程</li></ul><p>伪代码实现为：</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(object) &#123;  changeState(); <span class="hljs-comment">// 改变条件</span>  object.notifyAll(); <span class="hljs-comment">// 通知所有的等待线程</span>&#125;</code></pre><p>到这，我们回想一下前面关于<code>BlockingQueue</code>的入队和出队逻辑时，就是基于上面这种模式实现的。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>本文我们是Java并发编程系列的第2篇，主要介绍了Java中线程基础，包括线程的定义、基本用法、线程状态以及线程间通信的方法。后面我们会继续介绍Java中并发编程的知识，感谢各位小伙伴持续关注。</p><hr><blockquote><p><strong>我是「 毛与帆 」，如果本文对你有帮助，欢迎向各位小伙伴点赞、评论和关注，感谢各位老铁，我们下期见</strong></p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="mp_white"></p>]]></content>
    
    
    <categories>
      
      <category>深入理解Java系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发编程</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java系列 | 并发编程基础</title>
    <link href="/2021/005-java-concurrency-basic/"/>
    <url>/2021/005-java-concurrency-basic/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hi 大家好，我是「 毛与帆 」，一个热爱技术的后端工程师，感谢你的关注！</p></blockquote><p><img src="../../images/cover/005-java-concurrency-basic.png"></p><p>在前面的两篇文章中<a href="/2021/003-java-blocking-queue/">深入理解Java系列 | BlockingQueue用法详解</a>和<a href="/2021/004-java-linked-blocking-queue/">深入理解Java系列 | LinkedBlockingQueue用法详解</a>，主要介绍了阻塞队列的用法；而阻塞队列在Java中主要是用来进行多线程并发编程的场景，所以从本文开始将会从浅入深的介绍Java并发编程的相关知识。</p><p>首先，本文主要介绍并发编程的基础知识，现在开始吧。</p><h1 id="什么是并发编程？"><a href="#什么是并发编程？" class="headerlink" title="什么是并发编程？"></a>什么是并发编程？</h1><p>所谓并发编程，其实就是指在一台计算机上，可以同时执行多个任务，目的是尽可能提高程序的执行速度。</p><p>说到并发编程，不可避免的会谈到两个概念：<code>进程</code>和<code>线程</code>。</p><p>对于现代很多操作系统来说，都支持多任务处理，比如我们使用一台windows的计算机，可以同时使用浏览器、编程的IDE、聊天工具、邮件等多个程序，而每个程序对于操作系统来说其实就是<code>进程</code>。</p><p>所以进程就是<strong>一个正在执行的程序</strong>，一个进程是操作系统进行资源分配和管理的基本单位。</p><p>对于一个进程来说，也可以同时执行多个任务，比如我们使用浏览器时，可以一边浏览网页，一边进行文件的下载，这些子任务的执行，都是依赖<code>线程</code>实现的。<strong>线程是进程的组成部分，一个进程至少有一个线程组成，多个线程共享当前进程的资源</strong>。而线程也是操作系统进行任务执行和调度的基本单位，操作系统可以控制多个线程之间交替运行，以实现并发执行的效果。</p><p>OK，到这里，我们需要了解下操作系统是如何实现多线程执行的。</p><p>我们知道，现代的计算机通常都由多个CPU组成，多个CPU可以同时执行多个任务；而对于单个CPU，也是可以执行多个任务。单个CPU执行多个任务的方式，是通过让各个线程交替执行，比如线程A执行1ms，线程B执行1ms，线程A再执行1ms……由于每个线程单次执行的时间特别短，所以对于我们来说感觉是多个任务同时执行。CPU依赖<strong>时间片分配算法</strong>来进行任务的切换，某个任务从未执行到执行状态的切换，就完成了一次上下文的切换。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210831220322100.png" alt="image-20210831220322100"></p><p>所以，操作系统借助于多线程机制，实现了任务的并发执行。所以并发编程主要针对的也就是多线程场景下的编程实现。</p><h1 id="为什么并发编程这么重要？"><a href="#为什么并发编程这么重要？" class="headerlink" title="为什么并发编程这么重要？"></a>为什么并发编程这么重要？</h1><p>对于任何一门编程语言来说，并发编程都是非常重要一部分知识，也是非常复杂的领域；在面试过程中，并发编程也是面试官重点考察的内容。那么，为什么并发编程这么重要呢？</p><p>对并发编程知识的理解与否，决定了在日常开发中能否写出正确的程序，尤其是在涉及多线程编程开发时。在并发编程过程中，经常会遇到如下几个问题和挑战：</p><h2 id="1-多线程更快吗？"><a href="#1-多线程更快吗？" class="headerlink" title="1. 多线程更快吗？"></a>1. 多线程更快吗？</h2><p><strong>不一定。</strong></p><p>在上面的介绍中，我们知道多线程并发执行是依赖于CPU的时间片分配算法进行任务的调度和切换，当一个任务执行到时间后，需要将该任务的状态进行保存，然后切换到下个任务；如果需要再次执行这个任务，需要将从内存中加载任务状态并恢复，然后才可以再次执行。在这个过程中，<strong>任务从保存到加载的过程就是一次上下文切换</strong>。</p><p>线程的上下文切换需要进行任务状态的存储和读取，由于上下文切换需要耗费一定的时间，如果上下文切换的时间比一个任务执行的时间比还要长时，那么使用多线程的速度将会不如单个线程。</p><p>可以使用如下代码验证在不同数据量的情况下，单线程和多线程执行时间的对比（代码参考《Java并发编程的艺术》第1.1.1节）：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrencyTest</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]&#123;<span class="hljs-number">10000</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">1000000</span>, <span class="hljs-number">10000000</span>, <span class="hljs-number">100000000</span>&#125;;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count.length; i++) &#123;      System.out.println(<span class="hljs-string">&quot;===&gt; 测试数据量：&quot;</span> + count[i]);      <span class="hljs-comment">// 并发执行</span>      concurrency(count[i]);      <span class="hljs-comment">// 单线程执行</span>      serial(count[i]);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">concurrency</span><span class="hljs-params">(<span class="hljs-keyword">long</span> count)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;          a += <span class="hljs-number">5</span>;        &#125;      &#125;    &#125;);    thread.start();    <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;      b--;    &#125;    thread.join();    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();    System.out.println(<span class="hljs-string">&quot;多线程执行：&quot;</span> + (end - start));  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serial</span><span class="hljs-params">(<span class="hljs-keyword">long</span> count)</span> </span>&#123;    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;      a += <span class="hljs-number">5</span>;    &#125;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;      b--;    &#125;    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();    System.out.println(<span class="hljs-string">&quot;单线程执行：&quot;</span> + (end - start));  &#125;&#125;</code></pre><h2 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2. 线程安全问题"></a>2. 线程安全问题</h2><p>在并发编程中，遇到的另外一个非常棘手的问题，就是线程安全问题。在上面的介绍中讲到，线程是进程的组成部分，多个线程共享进程的资源，其中包括内存。当多个线程同时读写某个共享变量时，则可能会出现线程安全问题。</p><p>下面是一个常见的例子，对一个共享变量num，分别使用两个线程进行<code>++</code>操作5万次，我们期望的最终结果应该是10万，但是代码执行之后，多次运行的结果都小于10万。这也就表明，在多线程执行过程中，出现了线程安全问题。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrencyTest2</span> </span>&#123;  <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testThread</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;        num++;      &#125;    &#125;);    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50000</span>; j++) &#123;        num++;      &#125;    &#125;);    t1.start(); t2.start();    t1.join(); t2.join();    <span class="hljs-comment">// 期望是：100000</span>    <span class="hljs-comment">// 运行多次结果分别为：79967 97156 59108 62268 ....</span>    System.out.println(<span class="hljs-string">&quot;变量num : &quot;</span> + num);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">new</span> ConcurrencyTest2().testThread();  &#125;&#125;</code></pre><h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h2><p>通常，为了解决并发中的线程安全问题，会采用加锁的机制：也就是通过加锁对共享资源进行保护，使得同一个时间，只有一个线程对共享资源进行读或者写操作，这样就避免了共享资源的并发更新，保证了数据安全。</p><p>锁在解决线程安全问题中非常有用，但是使用锁就有可能会产生死锁问题，导致程序运行异常。</p><p>我们看下下面的例子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrencyTest3</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lockA = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lockB = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runThread1</span><span class="hljs-params">()</span> </span>&#123;    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lockA) &#123; <span class="hljs-comment">// 先获取锁A</span>          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁 A 成功&quot;</span>);          TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">// 省略try-catch</span>          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 尝试获取锁 B&quot;</span>);          <span class="hljs-keyword">synchronized</span> (lockB) &#123; <span class="hljs-comment">// 再获取锁B</span>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁 B 成功&quot;</span>);          &#125;        &#125;      &#125;    &#125;, <span class="hljs-string">&quot;thread-1&quot;</span>);    thread.start();  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runThread2</span><span class="hljs-params">()</span> </span>&#123;    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lockB) &#123; <span class="hljs-comment">// 先获取锁B</span>          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁 B 成功&quot;</span>);          TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>); <span class="hljs-comment">// 省略try-catch</span>          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 尝试获取锁 A &quot;</span>);          <span class="hljs-keyword">synchronized</span> (lockA) &#123; <span class="hljs-comment">// 再获取锁A</span>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁 A 成功&quot;</span>);          &#125;        &#125;      &#125;    &#125;, <span class="hljs-string">&quot;thread-2&quot;</span>);    thread.start();  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    runThread1();    runThread2();  &#125;&#125;</code></pre><p>在这个例子中，我们可以看到有两个锁对象<code>lockA</code>和<code>lockB</code>，并且有两个线程<code>thread-1</code>和<code>thread-2</code>。</p><p>在<code>thread-1</code>中，首先获取<code>lockA</code>的锁，然后休眠10秒，然后再获取<code>lockB</code>的锁；在<code>thread-2</code>中，首先获取<code>lockB</code>的锁，然后休眠10秒，然后再获取<code>lockA</code>的锁，此时，死锁就产生了。</p><p>由于<code>thread-1</code>和<code>thread-2</code>分别获取了lockA和lockB的锁，当<code>thread-1</code>休眠10秒结束后，尝试获取<code>lockB</code>的锁，但<code>lockB</code>的锁此时被<code>thread-2</code>占有而无法获取到，所以需要阻塞等待，在等待过程中，<code>thread-1</code>会一直持有<code>lockA</code>的锁；同样的，对于<code>thread-2</code>来说，当它需要获取<code>lockA</code>的锁时，由于<code>thread-1</code>一直持有不释放，导致<code>thread-2</code>无法获取成功，所以也会等待，并一直持有<code>lockB</code>的锁。两个线程一直等待对方所持有的锁而无法获取到，这就形成了死锁。</p><p>所以死锁就是：每个线程都在等待其他线程释放资源，而其他资源也在等待每个线程释放资源，没有线程先释放自己的资源，这种情况会产生死锁，所有线程都会无限的等待下去。</p><p><strong>造成死锁有4个必要条件：</strong></p><ul><li><code>互斥条件</code>：在一段时间内某资源只由一个线程占用。如果此时还有其它线程请求资源，只能等待，直至占有的线程释放资源。</li><li><code>请求和保持条件</code>：指线程已经持有至少一个资源，但又需要新的资源，而该资源已被其它线程占有，此时线程阻塞，并保持对资源的占有。</li><li><code>不剥夺条件</code>：指对于线程获得的资源，在未使用完之前，不能被剥夺，只能在使用完时才可以释放。</li><li><code>循环等待</code>：指发生死锁时，必然存在至少两个线程互相等待的情况</li></ul><p>对于上述4个条件，<strong>破坏其中一个条件就可以打破死锁</strong>。</p><h1 id="线程安全的三大问题"><a href="#线程安全的三大问题" class="headerlink" title="线程安全的三大问题"></a>线程安全的三大问题</h1><p>在上面讲到的几种并发常见的问题中，线程安全问题是最复杂且最常遇到的问题。为什么线程安全问题最复杂呢，主要是因为它受计算机硬件设备的发展、操作系统的原理、Java虚拟机的设计等原因的共同影响。</p><p>并发主要带来了线程安全的三大问题：<strong>可见性</strong>、<strong>原子性</strong>、<strong>有序性</strong>。下面我们一一进行叙述。</p><h2 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1. 可见性"></a>1. 可见性</h2><p>首先我们先简单介绍一下CPU的构成以及运行机制。</p><p>在操作系统中，CPU和内存是重要的两个组成部分。CPU的作用是是进行程序指令的执行，而内存的作用是存储程序执行中的数据。CPU在执行过程中，会对内存中的数据进行读取和更新。但是CPU的执行速度比内存的操作速度快了几个数量级，如果每次数据的读取和存储都从内存中进行，则CPU的执行速度会非常慢。</p><p>所以CPU在设计过程中，增加了多级缓存（CPU Cache），避免CPU与内存直接交互，提高访问内存的效率，CPU缓存的示意图如下：</p><ul><li>L1缓存容量最小，速度最快，每个核都有L1缓存；L1缓存一般又分为数据缓存L1D和指令缓存L1I</li><li>L2缓存容量比L1大，速度比L1慢，每个核都有L2缓存</li><li>L3缓存容量最大，速度最慢，多个核共享L3缓存</li></ul><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210831221429441.png" alt="image-20210831221429441"></p><p>由于CPU在执行过程中，会优先从CPU Cache中获取数据，当多级CPU Cache中都没有数据时，才会到主内存进行数据加载，所以大多数时候CPU 都在操作Cache，而某个CPU核心中Cache的数据，对于其他CPU核心是不可见的：比如某个变量在核1中进行了+1操作，但是在另外一个核2中无法感知这个+1操作，获取的还是+1操作前的值，如果在核2中再进行计算操作，则两个核心中的数据就会不一致。</p><p>CPU对线程的调度，是通过时间片分配算法进行的，每个线程的执行可能会在不同的CPU核心上进行上下文切换，所以如果一个线程在核1中对某个共享变量进行了更新，另外一个线程调度到核2执行时无法感知之前的更新，则就出现了数据不一致，这就是可见性问题。</p><p>出现这种情况，就需要启用<strong>缓存一致性协议</strong>，比如通过对共享变量增加<code>volatile</code>修饰，则变量在更新时，会立即刷新到主内存中；而且还会通过总线通知其他CPU缓存的该共享变量失效，需要重新从主内存进行读取。</p><h2 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2. 原子性"></a>2. 原子性</h2><p><strong>原子性是指一个操作，要么全部执行，要么全部不执行</strong>。在上面线程安全的示例代码中，我们对<code>num</code>进行的操作是<code>num++</code>，两个线程计算的结果，最终总是小于期望的结果。这其实是因为<code>num++</code>操作不是一个原子操作。我们来详细分析一下。</p><p>对于<code>num++</code>操作来说，其实是包含了3个步骤：读取num的值，执行num+1操作，将num+1的新值重新赋值给num（写回内存）。</p><p>当两个线程开始执行后，每个线程都会把num的值读取到CPU缓存中，并执行+1操作，然后再把计算后的值写回内存。由于两个线程在执行过程会被CPU进行调度而产生上下文切换，所以<code>num++</code>操作就可能被拆成多次执行，也就是变成了非原子操作。</p><p>比如当num = 0是，当线程t1将执行<code>num++</code>后变为1，则将<code>num = 1</code>写回到内存；线程t2在执行时，可能从内存中获取的值也是<code>num = 0</code>，执行<code>num++</code>后变为1，这次又将<code>num = 1</code>写回到内存，导致前一个更新被覆盖。这就是原子性问题的原因。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210831222516656.png" alt="image-20210831222516656"></p><p>在Java中，我们可以使用synchronized、lock或者atomic原子操作类，来避免出现原子问题，我们将在后面进行深入的探讨。</p><h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h2><p>有序性是指程序按照代码的先后顺序进行执行。而编译器为了优化程序的性能，有时候会改变语句的先后顺序。</p><p>比如<code>a = 1; b = 2;</code> 两个语句，编译器优化有有可能为<code>b = 2; a = 1;</code>。虽然对于这两个语句来说，上下调整顺序对执行的结果并没有什么影响，但是一旦在多线程环境下，对于某个共享变量的执行顺序调整后，就有可能影响程序执行的结果。</p><p>在Java的内存模型定义中，使用happens-before原则来规定编译器和处理器何时需要禁止重排序，来保证指令执行的有序性，这部分内容我们也会在后面详细探讨。</p><h2 id="4-三大问题总结"><a href="#4-三大问题总结" class="headerlink" title="4. 三大问题总结"></a>4. 三大问题总结</h2><p>通过上面的内容，我们可以针对三大线程安全做如下总结：</p><ul><li>CPU缓存的设计带来了可见性问题</li><li>多线程操作带来了原子性问题</li><li>指令重排序带来了有序性问题</li></ul><p>所以，并发编程的核心，就是如何有效的解决上述三大问题，保证程序的可靠性。在后面的章节，我们将会更深入的探讨并发编程的重点内容。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，本文主要介绍了并发编程的一些基础知识，以及并发编程带来的三大核心问题，在后面我们将会继续探讨在Java中如何解决并发编程的问题，欢迎各位小伙伴持续关注。</p><hr><blockquote><p><strong>我是「 毛与帆 」，如果本文对你有帮助，欢迎向各位小伙伴点赞、评论和关注，感谢各位老铁，我们下期见</strong></p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="mp_white"></p>]]></content>
    
    
    <categories>
      
      <category>深入理解Java系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java系列 | LinkedBlockingQueue用法详解</title>
    <link href="/2021/004-java-linked-blocking-queue/"/>
    <url>/2021/004-java-linked-blocking-queue/</url>
    
    <content type="html"><![CDATA[<blockquote><p> Hi 大家好，我是「 毛与帆 」，一个热爱技术的后端工程师，感谢你的关注！</p></blockquote><p><img src="../../images/cover/004-java-linked-blocking-queue.png" alt="i    mage-20210822210544483"></p><p>在前两篇文章<a href="/2021/002-java-queue/">深入理解Java系列 | Queue用法详解</a>和<a href="/2021/003-java-blocking-queue/">深入理解Java系列 | BlockingQueue用法详解</a>中，分别分析了Java中Queue接口和BlockingQueue接口的用法，在上一篇文章中分析了BlockingQueue的基于数组的实现类ArrayBlockingQueue，那么本文我们一起来研究下基于链表的实现类<code>LinkedBlockingQueue</code>的用法和原理。</p><p>现在开始吧!</p><h2 id="1-LinkedBlockingQueue的用法"><a href="#1-LinkedBlockingQueue的用法" class="headerlink" title="1. LinkedBlockingQueue的用法"></a>1. LinkedBlockingQueue的用法</h2><p>首先我们先来简单看下LinkedBlockingQueue的用法，下面是一个简单示例：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLinkedBlockingQueue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 初始化无界阻塞队列</span>    LinkedBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;();    <span class="hljs-comment">// 入队方法</span>    queue.add(<span class="hljs-number">1</span>);    queue.offer(<span class="hljs-number">2</span>);    <span class="hljs-keyword">try</span> &#123;      queue.offer(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);      queue.put(<span class="hljs-number">4</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      <span class="hljs-comment">// offer和put方法会抛出InterruptedException，需要捕获</span>      e.printStackTrace();    &#125;    <span class="hljs-comment">// 出队方法</span>    Integer x1 = queue.remove(); <span class="hljs-comment">// x1 = 1</span>    Integer x2 = queue.poll(); <span class="hljs-comment">// x2 = 2</span>    <span class="hljs-keyword">try</span> &#123;      Integer x3 = queue.poll(<span class="hljs-number">10</span>, TimeUnit.SECONDS); <span class="hljs-comment">// x3 = 3</span>      Integer x4 = queue.take(); <span class="hljs-comment">// x4 = 4</span>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      <span class="hljs-comment">// poll和take方法会抛出InterruptedException异常，需要捕获</span>      e.printStackTrace();    &#125;&#125;</code></pre><p>通过上面的示例，LinkedBlockingQueue提供了多个入队和出队方法，不同的方法的实现逻辑有所不同，下面我们一起看下<code>LinkedBlockingQueue</code>的原理吧。</p><h2 id="2-LinkedBlockingQueue类定义"><a href="#2-LinkedBlockingQueue类定义" class="headerlink" title="2. LinkedBlockingQueue类定义"></a>2. LinkedBlockingQueue类定义</h2><h3 id="2-1-基本类定义"><a href="#2-1-基本类定义" class="headerlink" title="2.1 基本类定义"></a>2.1 基本类定义</h3><p>首先我们看一下LinkedBlockingQueue的类定义，UML类图如下：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/image-20210822170331680.png" alt="image-20210822170331680"></p><p>从类图可以看出，LinkedBlockingQueue实现了BlockingQueue接口，并继承了AbstractQueue类，其代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<span class="hljs-comment">/** 队列的容量，如果不传则默认Integer.MAX_VALUE */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;<span class="hljs-comment">/** 当前队列中元素数量 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-comment">/**</span><span class="hljs-comment"> * 链表的头指针，head.item = null</span><span class="hljs-comment"> */</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 链表的尾指针 last.next = null</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<span class="hljs-comment">/** 出队操作锁 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">/** 出队条件：非空队列 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();<span class="hljs-comment">/** 入队锁 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">/** 入队条件：非满队列 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();&#125;</code></pre><p>在LinkedBlockingQueue中定义的变量及其含义如下：</p><ul><li><p><code>capacity</code>：该变量表示队列的容量，设置该值则变为一个有界队列；如果不设置的话默认取值为Integer.MAX_VALUE，也可以认为是无界队列</p></li><li><p><code>count</code>：当前队列中元素的数量</p></li><li><p><code>head</code>和<code>last</code>：分别表示链表的头尾节点，其中头结点<code>head</code>不存储元素，<code>head.item = null</code></p></li><li><p><code>takeLock</code>和<code>notEmpty</code>：出队的锁以及出队条件</p></li><li><p><code>putLock</code>和<code>notFull</code>：入队的锁以及入队条件</p></li></ul><p>可以看出与<code>ArrayBlockingQueue</code>不同的是，在<code>LinkedBlockingQueue</code>中，入队和出队分别使用两个锁，两个锁可以分别认为是毒写锁和读锁，这里的具体原因在后面会进行详细描述</p><h3 id="2-2-链表节点定义"><a href="#2-2-链表节点定义" class="headerlink" title="2.2 链表节点定义"></a>2.2 链表节点定义</h3><p><code>LinkedBlockingQueue</code>是基于链表实现的，所以链表的节点定义如下，在<code>Node&lt;E&gt;</code>节点中分别定义了元素<code>item</code>以及后继节点<code>next</code>。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    E item;    <span class="hljs-comment">// 后继节点，</span>    Node&lt;E&gt; next;    Node(E x) &#123; item = x; &#125;&#125;</code></pre><h3 id="2-3-构造方法定义"><a href="#2-3-构造方法定义" class="headerlink" title="2.3 构造方法定义"></a>2.3 构造方法定义</h3><p>然后我们再来看一下构造方法定义，在<code>LinkedBlockingQueue</code>中提供了三个构造方法，分别是默认构造方法、指定队列容量的构造方法、基于集合的构造方法；</p><p>在构造方法中，需要设置队列的容量，并初始化链表的头尾节点；基于集合的构造方法，会根据输入的集合，构建一个非空的队列。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 默认构造方法，队列容量为Integer.MAX_VALUE</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(Integer.MAX_VALUE);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 指定队列容量的构造方法</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">this</span>.capacity = capacity;    <span class="hljs-comment">// 初始化链表的头尾节点</span>    last = head = <span class="hljs-keyword">new</span> Node&lt;E&gt;(<span class="hljs-keyword">null</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于集合构建队列，默认容量为Integer.MAX_VALUE</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-keyword">this</span>(Integer.MAX_VALUE);    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;    putLock.lock(); <span class="hljs-comment">// Never contended, but necessary for visibility</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (E e : c) &#123;            <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            <span class="hljs-keyword">if</span> (n == capacity)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Queue full&quot;</span>);            enqueue(<span class="hljs-keyword">new</span> Node&lt;E&gt;(e));            ++n;        &#125;        count.set(n);    &#125; <span class="hljs-keyword">finally</span> &#123;        putLock.unlock();    &#125;&#125;</code></pre><h2 id="3-LinkedBlockingQueue入队和出队"><a href="#3-LinkedBlockingQueue入队和出队" class="headerlink" title="3. LinkedBlockingQueue入队和出队"></a>3. LinkedBlockingQueue入队和出队</h2><p>前面介绍了<code>LinkedBlockingQueue</code>的类的基本信息，包括类定义、变量、构造方法，下面我们就重点看下入队和出队方法。</p><h3 id="3-1-链表结构"><a href="#3-1-链表结构" class="headerlink" title="3.1 链表结构"></a>3.1 链表结构</h3><p>首先，我们先来温习一下如何基于链表实现队列进行入队和出队操作。在文章<a href="/2021/002-java-queue/">深入理解Java系列 | Queue用法详解</a>中，我们介绍了基于<code>LinkedList</code>如何实现双端队列功能，对于<code>LinkedBlockingQueue</code>来说，其链表结构为一个单向链表，其结构如下：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210822222127513.png" alt="链表结构"></p><p>队列的入队直接在链表尾结点进行操作，出队直接在链表头结点进行操作</p><h3 id="3-2-入队和出队方法"><a href="#3-2-入队和出队方法" class="headerlink" title="3.2 入队和出队方法"></a>3.2 入队和出队方法</h3><p>在前一篇文章 <a href="/2021/003-java-blocking-queue/">深入理解Java系列 | BlockingQueue用法详解</a> 中，我们知道<code>BlockingQueue</code>主要提供了四类方法，如下表所示，<code>LinkedBlockingQueue</code>实现了<code>BlockingQueue</code>接口，所以其方法也是如下四类。后面我们就重点看下入队和出队方法的实现</p><table><thead><tr><th>方法</th><th>抛出异常</th><th>返回特定值</th><th>阻塞</th><th>阻塞特定时间</th></tr></thead><tbody><tr><td>入队</td><td><code>add(e)</code></td><td><code>offer(e)</code></td><td><code>put(e)</code></td><td><code>offer(e, time, unit)</code></td></tr><tr><td>出队</td><td><code>remove()</code></td><td><code>poll()</code></td><td><code>take()</code></td><td><code>poll(time, unit)</code></td></tr><tr><td>获取队首元素</td><td><code>element()</code></td><td><code>peek()</code></td><td>不支持</td><td>不支持</td></tr></tbody></table><h3 id="3-3-入队操作put"><a href="#3-3-入队操作put" class="headerlink" title="3.3 入队操作put"></a>3.3 入队操作put</h3><p>首先我们来看下阻塞入队方法<code>put(e)</code>的实现原理，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-comment">// 入队锁上锁</span>    putLock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 如果队列中元素的数量等于队列的容量，则阻塞当前线程</span>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;            notFull.await();        &#125;        <span class="hljs-comment">// 执行入队操作</span>        enqueue(node);        <span class="hljs-comment">// 元素数量增1，返回操作前的数量</span>        c = count.getAndIncrement();        <span class="hljs-comment">// c+1为当前队列的元素，如果小于容量，则唤醒notFull的等待线程，触发继续入队操作</span>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)            notFull.signal();    &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// 释放锁</span>        putLock.unlock();    &#125;    <span class="hljs-comment">// c为入队前的元素数量，也就是入队前队列为空，则需要唤醒非空条件notEmpty的等待线程，触发出队操作</span>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)        signalNotEmpty();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalNotEmpty</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;    takeLock.lock();    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 唤醒出队等待的线程</span>        notEmpty.signal();    &#125; <span class="hljs-keyword">finally</span> &#123;        takeLock.unlock();    &#125;&#125;</code></pre><p>通过上面的代码，我们可以看出<code>put(e)</code>方法的主要流程如下：</p><ol><li>首先生成待插入节点<code>Node&lt;E&gt; node = new Node&lt;E&gt;(e)</code></li><li>然后尝试使用<code>putLock</code>上锁：如果当前无其他线程进行入队操作，则上锁成功；如果当前有其他线程进行入队操作，则进行等待，直到加锁成功；</li><li>加锁成功之后，首先进行队列容量的检查：如果元素数量等于队列容量，则无空间插入新元素，那么调用<code>notFull.await()</code>阻塞当前线程（当前线程被加入<code>notFull</code>条件的等待队列中；如果当前线程被唤醒，也需要再次检查是否有空间插入，如果没有还需要继续等待；</li><li>当队列有空间时，则调用<code>enqueue(node)</code>进行入队操作，将新节点<code>node</code>插入到链表中</li><li>入队完成后，对元素数量进行+1操作，并获取入队前的元素数量</li><li>判断当前元素数量小于队列容量时，则调用<code>notFull.signal()</code>唤醒一个等待入队的线程</li><li>释放锁</li><li>最后检查入队前元素数量为0，也就是队列为空时，那么此时队列不为空，则需要唤醒等待出队条件<code>notEmpty</code>的线程，触发出队操作，调用方法<code>signalNotEmpty</code></li></ol><p>到这里我们已经看完了整个<code>put(e)</code>操作的主流程，然后我们再看下<code>enqueue(node)</code>操作的具体逻辑，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> </span>&#123;    <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span>    <span class="hljs-comment">// assert last.next == null;</span>    last = last.next = node;&#125;</code></pre><p>在<code>enqueue(node)</code>操作中，就是将插入节点设置为尾结点的next节点，也就是<code>last.next = node</code>，然后再修改尾结点为新插入的节点，即：<code>last = last.next</code>，完成了入队节点的插入操作。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210822222709487.png" alt="入队操作"></p><h3 id="3-4-入队操作offer"><a href="#3-4-入队操作offer" class="headerlink" title="3.4 入队操作offer"></a>3.4 入队操作<code>offer</code></h3><p>在<code>LinkedBlockingQueue</code>中提供了两个offer重载方法，一个是<code>offer(E e)</code>，另外一个是<code>offer(E e, long timeout, TimeUnit unit)</code>，两者的区别如下：</p><p><code>offer(E e)</code>方法在入队时，如果当前队列有空间则直接入队，没有空间则入队失败，返回false；</p><p><code>offer(E e, long timeout, TimeUnit unit)</code>是带等待时间的阻塞入队方法，有空间直接入队，没有空间则等待特定的时间，如果依然无法入队，则返回false</p><p>下面看一下两个方法的具体源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-comment">// 加锁</span>    putLock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 检查队列是否满</span>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)                <span class="hljs-comment">// 此时无剩余时间，则入队失败，返回false</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 队列满则等待nanos时间；如果被唤醒，则返回剩余的等待时间</span>            <span class="hljs-comment">// 唤醒后依然需要重新检查队列容量，如果无空间则继续等待</span>            nanos = notFull.awaitNanos(nanos);        &#125;        <span class="hljs-comment">// 插入新节点</span>        enqueue(<span class="hljs-keyword">new</span> Node&lt;E&gt;(e));        c = count.getAndIncrement();        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)            notFull.signal();    &#125; <span class="hljs-keyword">finally</span> &#123;        putLock.unlock();    &#125;    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)        signalNotEmpty();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-comment">// 前置检查：如果队列满则直接返回false</span>    <span class="hljs-keyword">if</span> (count.get() == capacity)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;    <span class="hljs-comment">// 加锁</span>    putLock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 检查队列容量</span>        <span class="hljs-keyword">if</span> (count.get() &lt; capacity) &#123;            <span class="hljs-comment">// 队列有空间，则插入新节点</span>            enqueue(node);            c = count.getAndIncrement();            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)                notFull.signal();        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        putLock.unlock();    &#125;    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)        signalNotEmpty();    <span class="hljs-comment">// 返回是否入队成功</span>    <span class="hljs-keyword">return</span> c &gt;= <span class="hljs-number">0</span>;&#125;</code></pre><p>在上述代码中已经加了相关注释，重点看下判断队列容量的部分，在<code>offer(E e)</code>方法中，只进行一次判断，如果有空间才进行入队操作，队列满则不插入；在<code>offer(E e, long timeout, TimeUnit unit)</code>方法中，是在<code>while</code>循环中进行队列容量判断，当队列容量满时，判断是否到达指定的等待时间，如果未到等待时间则继续等待，到达等待时间则入队失败，返回<code>false</code>。</p><p>在插入新节点时，都是调用了<code>enqueue(node)</code>方法，并且插入完成后都进行了<code>notFull</code>和<code>notEmpty</code>条件的判断，尝试唤醒等待中的线程。</p><h3 id="3-5-入队操作add"><a href="#3-5-入队操作add" class="headerlink" title="3.5 入队操作add"></a>3.5 入队操作<code>add</code></h3><p>在<code>LinkedBlockingQueue</code>中，由于继承了<code>AbstractQueue</code>类，所以<code>add</code>方法也是使用的<code>AbstractQueue</code>中的定义，代码如下；<code>add</code>方法直接调用了<code>offer(E e)</code>方法，并判断是否入队成功，如果入队失败则抛出<code>IllegalStateException</code>异常。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 直接调用offer(e)方法进行入队</span>    <span class="hljs-keyword">if</span> (offer(e))        <span class="hljs-comment">// 入队成功：返回true</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 入队失败：抛出异常</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Queue full&quot;</span>);&#125;</code></pre><h3 id="3-6-出队操作take"><a href="#3-6-出队操作take" class="headerlink" title="3.6 出队操作take"></a>3.6 出队操作<code>take</code></h3><p>OK，前面我们已经了解了四类入队方法的实现，下面我们再来理解四类出队方法就会非常容易了，首先，我们还是先看阻塞出队方法<code>take()</code>的实现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    E x;    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;    <span class="hljs-comment">// 加锁</span>    takeLock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 判断队列容量，如果为空则等待</span>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;            notEmpty.await();        &#125;        <span class="hljs-comment">// 出队操作</span>        x = dequeue();        <span class="hljs-comment">// 队列元素数量-1，返回</span>        c = count.getAndDecrement();        <span class="hljs-comment">// 出队前队列元素大于1，也就是当前队列还有元素，则唤醒一个等待出队的线程</span>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)            notEmpty.signal();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        takeLock.unlock();    &#125;    <span class="hljs-comment">// 出队前队列元素等于队列容量，也就是出队后队列不满，则唤醒等待入队的线程</span>    <span class="hljs-keyword">if</span> (c == capacity)        signalNotFull();    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalNotFull</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;    putLock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 唤醒等待入队的线程</span>        notFull.signal();    &#125; <span class="hljs-keyword">finally</span> &#123;        putLock.unlock();    &#125;&#125;</code></pre><p>通过上面的代码，我们可以看出<code>take()</code>方法的主要流程如下：</p><ol><li>尝试使用<code>takeLock</code>上锁：如果当前无其他线程进行出队操作，则上锁成功；如果当前有其他线程进行出队操作，则进行等待，直到加锁成功；</li><li>加锁成功之后，首先进行队列容量的检查：如果队列为空，则调用<code>notEmpty.await()</code>阻塞当前线程；如果当前线程被唤醒，也需要再次检查队列是否为空，如果为空则继续等待；</li><li>当队列不为空，则调用<code>dequeue()</code>进行出队操作，返回出队元素x；</li><li>出队完成后，对元素数量进行-1操作，并获取出队前的元素数量</li><li>判断当前队列中是否还有元素，如果有则调用<code>notEmpty.signal()</code>唤醒一个等待出队的线程</li><li>释放锁</li><li>最后检查出队前队列是否满的，如果是满的，则出队后队列不满，则需要唤醒等待入队条件<code>notFull</code>的线程，触发入队操作，调用方法<code>signalNotFull</code></li></ol><p>在进行出队操作时，调用<code>dequeue()</code>方法，下面看下该方法的具体实现，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span>    <span class="hljs-comment">// assert head.item == null;</span>    <span class="hljs-comment">// 当前头结点（头结点不存储数据，第一个元素为head.next）</span>    Node&lt;E&gt; h = head;    <span class="hljs-comment">// 当前队列中第一个元素</span>    Node&lt;E&gt; first = h.next;    <span class="hljs-comment">// 原头结点设置无效</span>    h.next = h; <span class="hljs-comment">// help GC</span>    <span class="hljs-comment">// 最新的头结点指向第一个元素first</span>    head = first;    <span class="hljs-comment">// 获得第一个元素的值</span>    E x = first.item;    <span class="hljs-comment">// 将第一个元素值设置为null，第一个元素变成头结点</span>    first.item = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 返回第一个元素值</span>    <span class="hljs-keyword">return</span> x;&#125;</code></pre><p>出队示意图如下所示：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210822222758014.png" alt="出队操作"></p><h3 id="3-7-出队操作poll"><a href="#3-7-出队操作poll" class="headerlink" title="3.7 出队操作poll"></a>3.7 出队操作<code>poll</code></h3><p>同样的，<code>LinkedBlockingQueue</code>也提供了两个出队poll方法，一个是<code>poll()</code>，有元素则直接出队，无元素则返回null；另一个是<code>poll(long time, TimeUnit unit)</code>，带等待时间的出队方法，当有元素时直接出队，无元素时则等待特定时间。</p><p>两个方法的而具体实现请参考下面代码（代码中已经添加详细注释），这里不再赘述了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    E x = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;    <span class="hljs-comment">// 加锁</span>    takeLock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 检查队列容量，未到等待时间则继续等待，到达等待时间则返回null</span>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            nanos = notEmpty.awaitNanos(nanos);        &#125;        <span class="hljs-comment">// 出队操作</span>        x = dequeue();        <span class="hljs-comment">// 队列元素-1</span>        c = count.getAndDecrement();        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)            <span class="hljs-comment">// 队列元素不为空，唤醒等待出队的线程</span>            notEmpty.signal();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        takeLock.unlock();    &#125;    <span class="hljs-keyword">if</span> (c == capacity)        <span class="hljs-comment">// 队列容量未满，唤醒等待入队的线程</span>        signalNotFull();    <span class="hljs-comment">// 返回出队元素</span>    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-comment">// 前置判断，队列元素为空，则返回null</span>    <span class="hljs-keyword">if</span> (count.get() == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    E x = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;    <span class="hljs-comment">// 加锁</span>    takeLock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 检查队列容量，如果不为空则出队操作，为空则返回null</span>        <span class="hljs-keyword">if</span> (count.get() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 出队操作</span>            x = dequeue();            c = count.getAndDecrement();            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)                <span class="hljs-comment">// 队列元素不为空，唤醒等待出队的线程</span>                notEmpty.signal();        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 释放锁</span>        takeLock.unlock();    &#125;    <span class="hljs-keyword">if</span> (c == capacity)        <span class="hljs-comment">// 队列容量未满，唤醒等待入队的线程</span>        signalNotFull();    <span class="hljs-keyword">return</span> x;&#125;</code></pre><h3 id="3-8-出队操作remove"><a href="#3-8-出队操作remove" class="headerlink" title="3.8 出队操作remove"></a>3.8 出队操作<code>remove</code></h3><p>在<code>LinkedBlockingQueue</code>中，<code>remove</code>方法也是直接使用的父类<code>AbstractQueue</code>中的<code>remove</code>方法，代码如下；<code>remove</code>方法直接调用了<code>poll()</code>方法，如果出队成功则返回出队元素，出队失败则抛出<code>NoSuchElementException</code>异常。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 调用poll()方法进行出队</span>    E x = poll();    <span class="hljs-keyword">if</span> (x != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 出队成功：返回出队元素</span>        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">else</span>        <span class="hljs-comment">// 出队失败：抛出异常</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();&#125;</code></pre><h2 id="4-对比ArrayBlockingQueue"><a href="#4-对比ArrayBlockingQueue" class="headerlink" title="4. 对比ArrayBlockingQueue"></a>4. 对比ArrayBlockingQueue</h2><p>在前一篇文章<a href="/2021/003-java-blocking-queue/">深入理解Java系列 | BlockingQueue用法详解</a>中，我们分析了<code>ArrayBlockingQueue</code>中，使用了一个<code>ReentrantLock lock</code>作为入队和出队的锁，并使用两个条件<code>notEmpty</code>和<code>notFull</code>来进行线程间通信。而在本文介绍的<code>LinkedBlockingQueue</code>中，使用了两个锁<code>putLock</code>和<code>takeLock</code>分别作为入队和出队的锁，同样使用了两个锁的两个条件<code>notFull</code>和<code>notEmpty</code>进行线程间通信。</p><p>由于在<code>ArrayBlockingQueue</code>中，入队和出队操作共用了同一个锁，所以两个操作之间会有相互影响；而在<code>LinkedBlockingQueue</code>中，入队和出队操作分别使用不同的锁，则入队和出队互不影响，可以提供队列的操作性能。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>OK，在本文中我们详细分析了LinkedBlockingQueue的基础用法和底层原理，通过前面三篇文章，相信小伙伴们对Java中Queue和BlockingQueue的原理都有了深入的理解。在后面我会继续带来更多的深入理解Java的系列文章，感谢各位的关注！</p><hr><blockquote><p><strong>我是「 毛与帆 」，如果本文对你有帮助，欢迎向各位小伙伴点赞、评论和关注，感谢各位老铁，我们下期见</strong></p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="mp_white"></p>]]></content>
    
    
    <categories>
      
      <category>深入理解Java系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java系列 | BlockingQueue用法详解</title>
    <link href="/2021/003-java-blocking-queue/"/>
    <url>/2021/003-java-blocking-queue/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hi 大家好，我是「 毛与帆 」，一个热爱技术的后端工程师，感谢你的关注！</p></blockquote><p><img src="/2021/003-java-blocking-queue/image-20210808112835400.png" alt="image-20210808112835400"></p><p>在上一篇文章<a href="/2021/002-java-queue/">深入理解Java系列 |  Queue用法详解</a>中，我们一起研究了Java中Queue接口的用法和基本原理。我们知道，LinkedList实现的队列功能是非线程安全的，如果在多个线程进行入队和出队操作，将会产生数据不一致的情况。</p><p>所以在多线程环境下，我们需要线程安全的队列；在Java中，提供了两种线程安全队列的实现方式：一种是<strong>阻塞机制</strong>，另一种是<strong>非阻塞机制</strong>。</p><p>使用<strong>阻塞机制</strong>的队列，是通过使用锁的方式来实现，在入队和出队时通过加锁避免并发操作，比如本文将要介绍的<code>BlockingQueue</code>就是一个线程安全的阻塞队列；而使用<strong>非阻塞机制</strong>的队列，是通过使用CAS方式实现，比如<code>ConcurrentLinkedQueue</code>。</p><p>那么本文将主要介绍阻塞队列——<code>BlockingQueue</code>。闲话少说，进入正题吧！</p><h1 id="1-什么是BlockingQueue"><a href="#1-什么是BlockingQueue" class="headerlink" title="1. 什么是BlockingQueue?"></a>1. 什么是BlockingQueue?</h1><p><code>BlockingQueue</code>其实就是阻塞队列，是基于阻塞机制实现的线程安全的队列。而阻塞机制的实现是通过在入队和出队时加锁的方式避免并发操作。</p><p><code>BlockingQueue</code>不同于普通的<code>Queue</code>的区别主要是：</p><ol><li>通过在入队和出队时进行加锁，保证了队列线程安全</li><li>支持阻塞的入队和出队方法：当队列满时，会阻塞入队的线程，直到队列不满；当队列为空时，会阻塞出队的线程，直到队列中有元素。</li></ol><p><code>BlockingQueue</code>常用于<strong>生产者-消费者模型</strong>中，往队列里添加元素的是生产者，从队列中获取元素的是消费者；通常情况下生产者和消费者都是由多个线程组成；下图所示则为一个最常见的<strong>生产者-消费者模型</strong>，生产者和消费者之间通过队列平衡两者的的处理能力、进行解耦等。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/image-20210808104232215.png" alt="image-20210808104232215"></p><h1 id="2-BlockingQueue接口定义"><a href="#2-BlockingQueue接口定义" class="headerlink" title="2. BlockingQueue接口定义"></a>2. BlockingQueue接口定义</h1><p><code>BlockingQueue</code>继承了<code>Queue</code>接口，在Queue接口基础上，又提供了若干其他方法，其定义源码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 入队一个元素，如果有空间则直接插入，并返回true；</span><span class="hljs-comment">     * 如果没有空间则抛出IllegalStateException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 入队一个元素，如果有空间则直接插入，并返回true；</span><span class="hljs-comment">     * 如果没有空间返回false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 入队一个元素，如果有空间则直接插入，如果没有空间则一直阻塞等待</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 入队一个元素，如果有空间则直接插入，并返回true；</span><span class="hljs-comment">     * 如果没有空间则等待timeout时间，插入失败则返回false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 出队一个元素，如果存在则直接出队，如果没有空间则一直阻塞等待</span><span class="hljs-comment">     */</span>    <span class="hljs-function">E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 出队一个元素，如果存在则直接出队，如果没有空间则等待timeout时间，无元素则返回null</span><span class="hljs-comment">     */</span>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回该队列剩余的容量（如果没有限制则返回Integer.MAX_VALUE）</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remainingCapacity</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 如果元素o在队列中存在，则从队列中删除</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断队列中是否存在元素o</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将队列中的所有元素出队，并添加到给定的集合c中，返回出队的元素数量</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将队列中的元素出队，限制数量maxElements个，并添加到给定的集合c中，返回出队的元素数量</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> E&gt; c, <span class="hljs-keyword">int</span> maxElements)</span></span>;&#125;</code></pre><p><code>BlockingQueue</code>主要提供了四类方法，如下表所示：</p><table><thead><tr><th>方法</th><th>抛出异常</th><th>返回特定值</th><th>阻塞</th><th>阻塞特定时间</th></tr></thead><tbody><tr><td>入队</td><td><code>add(e)</code></td><td><code>offer(e)</code></td><td><code>put(e)</code></td><td><code>offer(e, time, unit)</code></td></tr><tr><td>出队</td><td><code>remove()</code></td><td><code>poll()</code></td><td><code>take()</code></td><td><code>poll(time, unit)</code></td></tr><tr><td>获取队首元素</td><td><code>element()</code></td><td><code>peek()</code></td><td>不支持</td><td>不支持</td></tr></tbody></table><p>除了<strong>抛出异常</strong>和<strong>返回特定值</strong>方法与Queue接口定义相同外，BlockingQueue还提供了两类阻塞方法：一种是当队列没有空间/元素时一直阻塞，直到有空间/有元素；另一种是在特定的时间尝试入队/出队，等待时间可以自定义。</p><p>在本文开始我们了解到，BlockingQueue是线程安全的队列，所以提供的方法也都是线程安全的；那么下面我们就继续看下BlockingQueue的实现类，以及如何实现线程安全和阻塞。</p><h1 id="3-BlockingQueue实现类及原理"><a href="#3-BlockingQueue实现类及原理" class="headerlink" title="3. BlockingQueue实现类及原理"></a>3. BlockingQueue实现类及原理</h1><h2 id="3-1-主要实现类"><a href="#3-1-主要实现类" class="headerlink" title="3.1 主要实现类"></a>3.1 主要实现类</h2><p>BlockingQueue接口主要由5个实现类，分别如下表所示。</p><table><thead><tr><th>实现类</th><th>功能</th></tr></thead><tbody><tr><td><strong><code>ArrayBlockingQueue</code></strong></td><td><strong>基于数组的阻塞队列</strong>，使用数组存储数据，并需要指定其长度，所以是一个<strong>有界队列</strong></td></tr><tr><td><strong><code>LinkedBlockingQueue</code></strong></td><td><strong>基于链表的阻塞队列</strong>，使用链表存储数据，默认是一个<strong>无界队列</strong>；也可以通过构造方法中的<code>capacity</code>设置最大元素数量，所以也可以作为<strong>有界队列</strong></td></tr><tr><td><strong><code>SynchronousQueue</code></strong></td><td>一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费</td></tr><tr><td><strong><code>PriorityBlockingQueue</code></strong></td><td>基于<strong>优先级别的阻塞队列</strong>，底层基于数组实现，是一个<strong>无界队列</strong></td></tr><tr><td><strong><code>DelayQueue</code></strong></td><td><strong>延迟队列</strong>，其中的元素只有到了其指定的延迟时间，才能够从队列中出队</td></tr></tbody></table><p>其中在日常开发中用的比较多的是<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>，本文也将主要介绍这两个实现类的原理。</p><h2 id="3-2-ArrayBlockingQueue的用法和原理"><a href="#3-2-ArrayBlockingQueue的用法和原理" class="headerlink" title="3.2 ArrayBlockingQueue的用法和原理"></a>3.2 ArrayBlockingQueue的用法和原理</h2><p><code>ArrayBlockingQueue</code>是基于数组实现的阻塞队列，下面我们看下它的主要用法。</p><h3 id="3-2-1-ArrayBlockingQueue的用法"><a href="#3-2-1-ArrayBlockingQueue的用法" class="headerlink" title="3.2.1 ArrayBlockingQueue的用法"></a>3.2.1 ArrayBlockingQueue的用法</h3><p>下面是<code>ArrayBlockingQueue</code>的一个简单示例：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testArrayBlockingQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  <span class="hljs-comment">// 创建ArrayBlockingQueue实例，设置队列大小为10</span>  BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">10</span>);  <span class="hljs-keyword">boolean</span> r1 = queue.add(<span class="hljs-number">1</span>);          <span class="hljs-comment">// 使用add方法入队元素，如果无空间则抛出异常</span>  <span class="hljs-keyword">boolean</span> r2 = queue.offer(<span class="hljs-number">2</span>);     <span class="hljs-comment">// 使用offer方法入队元素</span>  queue.put(<span class="hljs-number">3</span>);                    <span class="hljs-comment">// 使用put方法入队元素；如果无空间则会一直阻塞</span>  <span class="hljs-keyword">boolean</span> r3 = queue.offer(<span class="hljs-number">4</span>, <span class="hljs-number">30</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 使用offer方法入队元素；如果无空间则会等待30s</span>  Integer o1 = queue.remove();        <span class="hljs-comment">// 使用remove方法出队元素，如果无元素则抛出异常</span>  Integer o2 = queue.poll();          <span class="hljs-comment">// 使用poll方法出队元素 </span>  Integer o3 = queue.take();          <span class="hljs-comment">// 使用take方法出队元素；如果无元素则一直阻塞</span>  Integer o4 = queue.poll(<span class="hljs-number">10</span>, TimeUnit.SECONDS);       <span class="hljs-comment">// 使用poll方法出队元素； 如果无空间则等待10s</span>&#125;</code></pre><h3 id="3-2-2-ArrayBlockingQueue的原理"><a href="#3-2-2-ArrayBlockingQueue的原理" class="headerlink" title="3.2.2 ArrayBlockingQueue的原理"></a>3.2.2 ArrayBlockingQueue的原理</h3><p>OK，下面我们来看一下ArrayBlockingQueue的实现原理，首先看一下类的定义</p><h4 id="（1）类定义"><a href="#（1）类定义" class="headerlink" title="（1）类定义"></a><strong>（1）类定义</strong></h4><p>首先我们看到ArrayBlockingQueue的类定义如下，实现了<code>BlockingQueue</code>接口，并继承了抽象队列类<code>AbstractQueue</code>（封装了部分通用方法）。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;  <span class="hljs-comment">/** 使用数组存储队列中的元素 */</span>  <span class="hljs-keyword">final</span> Object[] items;  <span class="hljs-comment">/** 下一个出队元素在items数组中的索引 */</span>  <span class="hljs-keyword">int</span> takeIndex;  <span class="hljs-comment">/** 下一个出队元素需要存放在items数组中的索引 */</span>  <span class="hljs-keyword">int</span> putIndex;  <span class="hljs-comment">/** 队列中的元素数量 */</span>  <span class="hljs-keyword">int</span> count;  <span class="hljs-comment">/** 使用在许多教科书中能找到的经典的`双Condition算法`进行并发控制 */</span>  <span class="hljs-comment">/** 使用独占锁ReetrantLock */</span>  <span class="hljs-keyword">final</span> ReentrantLock lock;  <span class="hljs-comment">/** 等待出队的条件 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;  <span class="hljs-comment">/** 等待入队的条件 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;&#125;</code></pre><p>在ArrayBlockingQueue中，还定义了队列元素存储以及入队、出队操作的属性。</p><ul><li><code>final Object[] items</code>：由于ArrayBlockingQueue是基于数组实现的阻塞队列，所以使用<code>items</code>数组，存储队列中的元素;</li><li><code>int takeIndex</code>和<code>int putIndex</code>：两个items数组的索引值，分别指向出队元素的索引值以及将要入队元素的索引值；通过这两个索引，可以控制元素从<code>items</code>数组中如何进行出队和入队；</li><li><code>int count</code>：当前队列中的元素数量，通过该值实现了队列有界性；</li></ul><p>除了上述几个属性，还需要部分属性进行并发控制，在BlockingQueue中使用了<code>双Condition算法</code>进行并发控制，主要通过如下几个变量实现：</p><ul><li><code>ReentrantLock lock</code>：这里使用了ReetrantLock作为独占锁，进行并发控制</li><li><code>Condition notEmpty</code>和<code>Condition notFull</code>：定义了两个阻塞唤醒条件，分别表示<code>等待出队的条件</code>和<code>等待入队的条件</code></li></ul><h4 id="（2）构造方法"><a href="#（2）构造方法" class="headerlink" title="（2）构造方法"></a><strong>（2）构造方法</strong></h4><p>在ArrayBlockingQueue构造方法中，主要功能时初始化元素数组以及锁和condition条件；可以通过<code>capacity</code>变量指定有界队列的元素数量，以及通过<code>fair</code>指定是否使用公平锁。</p><pre><code class="hljs java"><span class="hljs-comment">/** 指定队列元素数量capacity，并使用非公平锁进行并发控制 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;  <span class="hljs-keyword">this</span>(capacity, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-comment">/** 指定队列元素数量capacity，并通过fair变量指定使用公平锁/非公平锁进行并发控制*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;  <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();  <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> Object[capacity]; <span class="hljs-comment">// 初始化元素数组</span>  lock = <span class="hljs-keyword">new</span> ReentrantLock(fair);<span class="hljs-comment">// 初始化锁</span>  notEmpty = lock.newCondition(); <span class="hljs-comment">// 初始化出队条件</span>  notFull =  lock.newCondition();<span class="hljs-comment">// 初始化入队条件</span>&#125;</code></pre><h4 id="（3）入队逻辑"><a href="#（3）入队逻辑" class="headerlink" title="（3）入队逻辑"></a><strong>（3）入队逻辑</strong></h4><p>上面我们已经了解了类定义、对象属性以及构造方法，下面我们重点看下元素的入队和出队操作。在阅读入队的源码之前，我们先考虑下，如何基于数组实现一个有界队列，并提供入队和出队操作呢？</p><p>首先，我们需要两个索引，分别指向出队和入队的元素所在数组中的位置，也就是类定义中的<code>takeIndex</code>和<code>putIndex</code>；还需要一个变量记录当前队列中的元素数量<code>count</code>，在出队和入队时根据<code>count</code>判断是否有元素或者是否有空间。</p><p>如下图所示，则为一个容量为8的队列数组，在初始状态下，<code>takeIndex</code>和<code>putIndex</code>均指向数组的索引0处，且该数组中元素的数量<code>count</code>为0。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210808174045834.png" alt="数组初始状态"></p><p>然后，我们尝试<strong>入队一个元素A</strong>。由于目前数组中元素数量count未超过容量8，所以将元素A放置在数组的<code>putIndex</code>索引处，也就是索引0处；然后，由于<code>putIndex</code>所指向的为下一个入队元素的索引，所以要将<code>putIndex+1</code>，即<code>putIndex = 1</code>。这样就完成了一个元素的入队操作。依次递推，可以继续入队元素B、C、D……</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210808222810647.png" alt="入队第一个元素A"></p><p>当<strong>入队第8个元素H</strong>时，此时数组中元素数量<code>count=7</code>，且<code>putIndex=7</code>，所以将元素H放置在数组的索引7处；然后对<code>putIndex</code>进行加1操作；但是此时由于<code>putIndex</code>超出了数组的最大索引，所以将<code>putIndex</code>置为0，也就是指向了数组的索引0处。所以在这里，该数组其实是作为一个<strong>循环数组</strong>使用。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210808182711203.png" alt="入队第8个元素H"></p><p>此时队列中的元素数量已经达到了容量限制，当<strong>入队第九个元素I</strong>时，由于容量限制，无法直接入队成功，则需要进行等待，直到队列中的元素数量小于容量限制时才可以再次入队。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210808183433921.png" alt="入队第九个元素I"></p><p>在<code>ArrayBlockingQueue</code>中入队逻辑的方法为<code>enqueue</code>，下面是其具体代码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">   * 在当前位置插入元素，并修改索引值，并唤醒非空队列的线程</span><span class="hljs-comment">   * 只有在获取锁的情况才会调用</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E x)</span> </span>&#123;      <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;      <span class="hljs-comment">// 将元素插入到putIndex处</span>      items[putIndex] = x;      <span class="hljs-comment">// 修改putIndex索引</span>      <span class="hljs-keyword">if</span> (++putIndex == items.length)          <span class="hljs-comment">// 如果修改后putIndex超出items数组最大索引，则指向索引0处</span>          putIndex = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 元素数量+1</span>      count++;      <span class="hljs-comment">// 唤醒一个非空队列中的线程</span>      notEmpty.signal();  &#125;</code></pre><h4 id="（4）出队逻辑"><a href="#（4）出队逻辑" class="headerlink" title="（4）出队逻辑"></a><strong>（4）出队逻辑</strong></h4><p>OK，上面我们了解了元素入队的逻辑，然后我们再看下如何实现出队？</p><p>首先，当队列处于初始状态时，<code>count=0</code>且<code>takeIndex=0</code>，这次数组中没有任何元素，所以无法进行出队，需要进行阻塞等待，直到队列中有元素时才可以进行再次出队。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210808222349874.png" alt="数组初始状态"></p><p>当数组中存在元素时，如下图所示，数组中有4个元素，其中<code>count=4</code>，且<code>takeIndex=0</code>，<code>putIndex=4</code>。此时当执行出队时，则将<code>takeIndex=0</code>处的元素A出队，并将数组该索引处置为null；然后将<code>takeIndex</code>修改指向为下一个待出队的元素B，也就是<code>takeIndex=1</code>，并修改元素数量<code>count=3</code>。此时完成了出队操作。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210808223116214.png" alt="出队第一个元素A"></p><p>由于该数组为循环数组，当出队元素索引<code>takeIndex</code>超出数组的最大索引时，需要将<code>takeIndex</code>修改为0。</p><p>在<code>ArrayBlockingQueue</code>中出队逻辑的方法为<code>dequeue</code>，下面是其具体代码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">   * 在当前位置获取一个元素，并修改索引值，并唤醒非满队列的线程</span><span class="hljs-comment">   * 只有在获取锁的情况下才会调用</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;      <span class="hljs-comment">// 获取当前索引处元素</span>      E x = (E) items[takeIndex];      <span class="hljs-comment">// 将当前索引处置为空</span>      items[takeIndex] = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// 修改takeIndex索引</span>      <span class="hljs-keyword">if</span> (++takeIndex == items.length)          <span class="hljs-comment">// 如果修改后takeIndex超出items数组最大索引，则指向索引0处</span>          takeIndex = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 元素数量-1</span>      count--;      <span class="hljs-keyword">if</span> (itrs != <span class="hljs-keyword">null</span>)          itrs.elementDequeued();    <span class="hljs-comment">// 唤醒一个非满队列中的线程</span>      notFull.signal();      <span class="hljs-keyword">return</span> x;  &#125;</code></pre><h4 id="（5）阻塞实现"><a href="#（5）阻塞实现" class="headerlink" title="（5）阻塞实现"></a><strong>（5）阻塞实现</strong></h4><p>通过上面的描述，我们了解了基于数组的阻塞队列的入队和出队实现逻辑，但是我们还剩下最后一个疑问，当入队和出队时，如果无法直接进行入队和出队操作，需要进行阻塞等待，那么阻塞是如何实现的呢？在<code>ArrayBlockingQueue</code>中主要是使用独占锁<code>ReentrantLock</code>以及两个条件队列<code>notFull</code>和<code>notEmpty</code>实现的。</p><p>我们首先看一下阻塞入队的方法<code>put(E e)</code>，下面是其代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      checkNotNull(e);      <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;      <span class="hljs-comment">// 加锁</span>      lock.lockInterruptibly();      <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">while</span> (count == items.length) &#123;            <span class="hljs-comment">// 如果队列已满，线程阻塞，并添加到notFull条件队列中等待唤醒</span>            notFull.await();          &#125;          <span class="hljs-comment">// 如果队列未满，则调用enqueue方法进行入队操作</span>          enqueue(e);      &#125; <span class="hljs-keyword">finally</span> &#123;          <span class="hljs-comment">// 释放锁</span>          lock.unlock();      &#125;  &#125;</code></pre><p>调用<code>put</code>方法进行阻塞式入队的基本流程为：</p><ul><li><p>首先，在进行入队操作前，使用<code>ReentrantLock</code>进行加锁操作，保证只有一个线程执行入队或出队操作；如果锁被其他线程占用，则等待；</p></li><li><p>如果加锁成功，则首先判断队列是否满，也就是<code>while(count == items.length)</code>；如果队列已满，则调用<code>notFull.await()</code>，将当前线程阻塞，并添加到<code>notFull条件队列</code>中等待唤醒；如果队列不满，则直接调用<code>enqueue</code>方法，进行元素插入；</p></li><li><p>当前线程添加到<code>notFull</code>条件队列中后，只有当其他线程有出队操作时，会调用<code>notFull.signal()</code>方法唤醒等待的线程；当前线程被唤醒后，还需要再次进行一次队列是否满的判断，如果此时队列不满才可以进行<code>enqueue</code>操作，否则仍然需要再次阻塞等待，这也就是为什么在判断队列是否满时使用<code>while</code>的原因，即避免当前线程被意外唤醒，或者唤醒后被其他线程抢先完成入队操作。</p></li><li><p>最后，当完成入队操作后，在finally代码块中进行锁释放<code>lock.unlock</code>，完成<code>put</code>入队操作</p></li></ul><p>下面我们再来看下阻塞出队方法<code>take()</code>，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;      <span class="hljs-comment">// 加锁</span>      lock.lockInterruptibly();      <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)              <span class="hljs-comment">// 判断队列是否为空，如果为空则线程阻塞，添加到notEmpty条件队列等待</span>              notEmpty.await();          <span class="hljs-comment">// 队列不为空，进行出队操作</span>          <span class="hljs-keyword">return</span> dequeue();      &#125; <span class="hljs-keyword">finally</span> &#123;          <span class="hljs-comment">// 释放锁</span>          lock.unlock();      &#125;  &#125;</code></pre><p>其实<code>take</code>方法与<code>put</code>方法类似，主要流程也是先加锁，然后循环判断队列是否为空，如果为空则添加到notEmpty条件队列等待，如果不为空则进行出队操作；最后进行锁释放。</p><h4 id="（6）指定等待时间的阻塞实现"><a href="#（6）指定等待时间的阻塞实现" class="headerlink" title="（6）指定等待时间的阻塞实现"></a>（6）指定等待时间的阻塞实现</h4><p>OK，到这里我们了解了如何进行阻塞的入队和出队操作，在<code>ArrayBlockingQueue</code>中还支持指定等待时间的阻塞式入队和出队操作，分别是<code>offer(e, time, unit)</code>和<code>poll(time, unit)</code>方法。这里我们就只要看下<code>offer(e, time, unit)</code>的实现逻辑，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      checkNotNull(e);      <span class="hljs-comment">// 获取剩余等待时间</span>      <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);      <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;      <span class="hljs-comment">// 加锁</span>      lock.lockInterruptibly();      <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">// 判断队列是否满</span>          <span class="hljs-keyword">while</span> (count == items.length) &#123;              <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)                  <span class="hljs-comment">// 入队队列满，等待时间为0，则入队失败，返回false</span>                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;              <span class="hljs-comment">// 如果队列满，等待时间大于0，且未到等待时间，则继续等待nanos</span>              nanos = notFull.awaitNanos(nanos);          &#125;          <span class="hljs-comment">// 队列不满，进行入队操作</span>          enqueue(e);          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">finally</span> &#123;          <span class="hljs-comment">// 释放锁</span>          lock.unlock();      &#125;  &#125;</code></pre><p>在上面代码中，我们重点看下<code>while</code>循环中判断队列是否满的条件：</p><ul><li>当队列满时，则首先判断剩余等待时间是否为0，如果为0表示已经到了等待时间，此时入队失败，直接返回<code>false</code></li><li>当剩余等待时间大于0时，则需要继续等待，即调用<code>nanos = notFull.awaitNanos(nanos)</code>，当该线程被唤醒时，<code>awaitNanos</code>会返回剩余的等待时间nanos，根据nanos则可以判断是否已经到等待时间。</li></ul><p>在出队方法<code>poll(time, unit)</code>方法中，实现逻辑类似，这里不再赘述，有兴趣的小伙伴可以自行查看源码研究哦。</p><h3 id="3-2-3-ArrayBlockingQueue原理总结"><a href="#3-2-3-ArrayBlockingQueue原理总结" class="headerlink" title="3.2.3 ArrayBlockingQueue原理总结"></a>3.2.3 ArrayBlockingQueue原理总结</h3><p>到这里我们终于搞明白了<code>ArrayBlockingQueue</code>的实现原理，以及入队和出队的具体逻辑，我们最后来个总结：</p><ul><li>ArrayBlockingQueue是一个有界阻塞队列，初始化时需要指定容量大小。</li><li>在生产者-消费者模型中使用时，如果生产速度和消费速度基本匹配的情况下，使用ArrayBlockingQueue是个不错选择；当如果生产速度远远大于消费速度，则会导致队列填满，大量生产线程被阻塞。</li><li>使用独占锁ReentrantLock实现线程安全，入队和出队操作使用同一个锁对象，也就是只能有一个线程可以进行入队或者出队操作；这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈。</li></ul><p>限于篇幅，LinkedBlockingQueue的用法和原理将在下一篇文章中进行分析，请持续关注。</p><hr><blockquote><p><strong>我是「 毛与帆 」，如果本文对你有帮助，欢迎向各位小伙伴点赞、评论和关注，感谢各位老铁，我们下期见</strong></p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="mp_white"></p>]]></content>
    
    
    <categories>
      
      <category>深入理解Java系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java系列 | Queue用法详解</title>
    <link href="/2021/002-java-queue/"/>
    <url>/2021/002-java-queue/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hi 大家好，我是「 毛与帆 」，一个热爱技术的后端工程师，感谢你的关注！</p></blockquote><p><img src="../../images/cover/002-java-queue.png" alt="image-20210727215303429"></p><p>从今天开始我将会带来<strong>深入理解Java系列</strong>文章，主要目的是重温Java中的基础概念、数据结构、多线程、锁、JUC等重点知识点。本文我们一起来研究下Java中Queue的用法。</p><h2 id="1-什么是Queue？"><a href="#1-什么是Queue？" class="headerlink" title="1. 什么是Queue？"></a>1. 什么是Queue？</h2><p><code>Queue</code>也就是队列，是一种基本的<code>线性数据结构</code>，与之类似的其他数据结构还有数组、链表、栈等。</p><p>Queue是一种遵循<strong>先进先出</strong>（<code>FIFO: First In, First Out</code>）原则的数据集合，数据在Queue中的流动是单向的，从队尾流向队首。</p><p>如下图所示，元素的插入发生在队尾，删除发生在队首；通常一个元素从队首中取出后，该元素从Queue中删除；非队首的元素，无法直接对其进行读取。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210722231940064.png" alt="image-20210722231940064"></p><p>在现实世界中队列非常常见，比如排队等待购票、上车的乘客，流水线上一个个等待处理的产品，都是一种队列模型；而且程序设计的世界中队列使用也非常广泛：比如多线程中等待处理的任务、排队等待获取某个锁的线程等。</p><p>下面我们一起来看下Java中Queue的主要用法和原理吧。</p><h2 id="2-Java中的Queue接口"><a href="#2-Java中的Queue接口" class="headerlink" title="2. Java中的Queue接口"></a>2. Java中的Queue接口</h2><h3 id="2-1-Queue接口定义"><a href="#2-1-Queue接口定义" class="headerlink" title="2.1 Queue接口定义"></a>2.1 Queue接口定义</h3><p>在Java中，队列是一种基本的集合类型，提供了队列接口<code>Queue</code>，定义在  其中<code>java.util</code>包中；其中<code>Queue</code>接口继承了基础集合接口<code>Collection</code>。</p><p>Queue接口定义如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>在Queue接口中，定义基本的元素插入和删除的方法，主要方法及其含义分别如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>向队列中添加一个元素；如果有空间则添加成功返回true，否则则抛出<code>IllegalStateException</code>异常</td></tr><tr><td><code>boolean offer(E e)</code></td><td>向队列中添加一个元素；如果有空间则添加成功返回true，否则返回false</td></tr><tr><td><code>E remove()</code></td><td>从队列中删除一个元素；如果元素存在则返回队首元素，否则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td><code>E poll();</code></td><td>从队列中删除一个元素；如果元素存在则返回队首元素，否则返回null</td></tr><tr><td><code>E element()</code></td><td>从队列获取一个元素，但是不删除；如果元素存在则返回队首元素，否则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td><code>E peek()</code></td><td>从队列获取一个元素，但是不删除；如果元素存在则返回队首元素，否则返回null</td></tr></tbody></table><h3 id="2-2-双端队列：Deque接口"><a href="#2-2-双端队列：Deque接口" class="headerlink" title="2.2 双端队列：Deque接口"></a>2.2 双端队列：Deque接口</h3><p>在上面的Queue接口定义中，实现了最基本的元素插入和删除方法，也就是从队尾进行元素插入，在队首进行元素删除；而Java还提供了另一个功能强大的<code>Deque接口</code>，实现了<strong>双端队列</strong>的功能。</p><p><strong>什么是双端队列？</strong></p><p>双端队列就是可以支持在队首或者队尾，都可以进行元素的插入和删除操作的队列，如下图所示。在双端队列中，分别使用<code>first</code>和<code>last</code>表示队列的首、尾两端，而在插入或删除元素时，可以通过指定在队列的哪一端进行操作。</p><p>比如：<code>offerFirst(A)</code>表示在队首进行元素的插入，<code>pollLast()</code>表示在队尾进行元素的删除。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210725205419168.png" alt="image-20210725205419168"></p><p><strong>Deque接口的定义如下</strong>：</p><p>可以看到，<code>Deque</code>接口继承了<code>Queue</code>接口，除了基本的<code>Queue</code>接口的方法外，<code>Deque</code>还提供了<strong>双端队列</strong>的操作方法，如代码所示，每个操作方法与<code>Queue</code>的操作方法类似，只是指定了在队首还是队尾进行元素操作。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;  <span class="hljs-comment">// 向队首添加一个元素；如果有空间则添加成功返回true，否则则抛出`IllegalStateException`异常</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;    <span class="hljs-comment">// 向队尾添加一个元素；如果有空间则添加成功返回true，否则则抛出`IllegalStateException`异常</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;  <span class="hljs-comment">// 向队首添加一个元素；如果有空间则添加成功返回true，否则返回false</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;<span class="hljs-comment">// 向队尾添加一个元素；如果有空间则添加成功返回true，否则返回false</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;  <span class="hljs-comment">// 从队首删除一个元素；如果元素存在则返回队首元素，否则抛出`NoSuchElementException`异常</span>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 从队尾删除一个元素；如果元素存在则返回队尾元素，否则抛出`NoSuchElementException`异常</span>    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 从队首删除一个元素；如果元素存在则返回队首元素，否则返回null</span>    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 从队尾删除一个元素；如果元素存在则返回队首元素，否则返回null</span>    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 从队首获取一个元素，但是不删除；如果元素存在则返回队首元素，否则抛出`NoSuchElementException`异常</span>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 从队尾获取一个元素，但是不删除；如果元素存在则返回队尾元素，否则抛出`NoSuchElementException`异常</span>    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 从队首获取一个元素，但是不删除；如果元素存在则返回队首元素，否则返回null</span>    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 从队尾获取一个元素，但是不删除；如果元素存在则返回队尾元素，否则返回null</span>    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 如果元素o存在，则从队列中删除第一次出现的该元素</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span></span>;  <span class="hljs-comment">// 如果元素o存在，则从队列中删除最后一次出现的该元素</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span></span>;    <span class="hljs-comment">// 其他方法省略....</span>&#125;</code></pre><h3 id="2-3-实现类-LinkedList"><a href="#2-3-实现类-LinkedList" class="headerlink" title="2.3 实现类 LinkedList"></a>2.3 实现类 LinkedList</h3><p>在前面，我们了解了Java中定义的两个队列接口<code>Queue</code>和<code>Deque</code>，而两个接口的实现类是通过<code>LinkedList</code>来实现的。从类名定义上可以看出来，<code>LinkedList</code>其实是基于链表实现的List的一个数据集合，而且<code>LinkedList</code>还实现了<code>Queue</code>接口和<code>Deque</code>接口。我们可以直接使用<code>LinkedList</code>来实现队列的操作。下面是其定义：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><span class="hljs-class"></span>&#123;...&#125;</code></pre><p>下面是一个基于<code>LinkedList</code>实现的双端队列的例子：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Deque&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-comment">// 元素入队</span>  queue.offer(<span class="hljs-string">&quot;1&quot;</span>);  queue.offer(<span class="hljs-string">&quot;2&quot;</span>);  queue.offer(<span class="hljs-string">&quot;3&quot;</span>);  queue.offerFirst(<span class="hljs-string">&quot;0&quot;</span>);  <span class="hljs-comment">// 队首添加元素0</span>  queue.offerLast(<span class="hljs-string">&quot;4&quot;</span>);   <span class="hljs-comment">// 队尾添加元素4</span>  System.out.println(queue);  <span class="hljs-comment">// 此时队列中的元素为：[0, 1, 2, 3, 4]</span>  <span class="hljs-comment">// 元素出队</span>  System.out.println(queue.poll());       <span class="hljs-comment">// 删除队首元素，打印值：0</span>  System.out.println(queue.pollFirst());  <span class="hljs-comment">// 删除队首元素，打印值：1</span>  System.out.println(queue.pollLast());   <span class="hljs-comment">// 删除队尾元素，打印值：4</span>&#125;</code></pre><p>OK，到这儿我们已经了解了队列接口的定义以及实现类LinkedList的定义以及使用方法，下面我们简单看下LinkedList底层是如何实现的队列功能。</p><h2 id="3-LinkedList如何实现队列功能"><a href="#3-LinkedList如何实现队列功能" class="headerlink" title="3. LinkedList如何实现队列功能"></a>3. LinkedList如何实现队列功能</h2><h3 id="3-1-链表的定义"><a href="#3-1-链表的定义" class="headerlink" title="3.1 链表的定义"></a>3.1 链表的定义</h3><p>上面我们了解到，<code>LinkedList</code>其实是基于链表实现的一个数据集合，并实现了队列的接口功能。我们再来看下<code>LinkedList</code>的定义和成员变量。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><span class="hljs-class"></span>&#123;  <span class="hljs-comment">// 元素数量</span>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 队首元素节点</span>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;  <span class="hljs-comment">// 队尾元素节点</span>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;  <span class="hljs-comment">// ......</span>&#125;</code></pre><p>可以看到，在LinkedList中有两个成员变量<code>first</code>和<code>last</code>，类型为<code>Node&lt;E&gt;</code>，分别表示队列中队首和队尾的节点，其实也就是链表中的首尾节点。<code>Node&lt;E&gt;</code>是链表的一个节点，下面是其定义：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;  <span class="hljs-comment">// 元素值</span>  E item;  <span class="hljs-comment">// 后一个节点</span>  Node&lt;E&gt; next;  <span class="hljs-comment">// 前一个节点</span>  Node&lt;E&gt; prev;  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;    <span class="hljs-keyword">this</span>.item = element;    <span class="hljs-keyword">this</span>.next = next;    <span class="hljs-keyword">this</span>.prev = prev;  &#125;&#125;</code></pre><p>在<code>Node&lt;E&gt;</code>中，成员变量<code>item</code>用来存储具体的元素值，另外两个<code>Node&lt;E&gt;</code>类型的变量<code>next</code>和<code>prev</code>分别表示该节点的<strong>后一个节点</strong>和<strong>上一个节点</strong>。</p><p>到此，我们就可以知道，<code>LinkedList</code>其实是由一个<strong>双向链表</strong>构成，并通过<code>first</code>和<code>last</code>分别表示链表的首尾节点。然后我们可以画出下面这个链表的示意图。</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210725221222893.png" alt="image-20210725221222893"></p><h3 id="3-2-元素的插入"><a href="#3-2-元素的插入" class="headerlink" title="3.2 元素的插入"></a>3.2 元素的插入</h3><p>在前面的介绍中，我们知道，元素的插入可以使用<code>add</code>和<code>offer</code>两个方法，不同的是当队列容量不足时，<code>add</code>方法会抛除异常，而<code>offer</code>方法会返回false。但是<code>LinkedList</code>是基于双向链表实现，理论上该链表是无界的，只要程序内存允许，可以一直插入新的元素。</p><p>下面我们看下<code>offer</code>方法插入元素的实现逻辑，代码如下（已添加相关注释）：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 插入元素</span><span class="hljs-comment">   */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 此处直接调用了add方法</span>    <span class="hljs-keyword">return</span> add(e);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 插入元素</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<span class="hljs-comment">// 调用linkLast方法</span>    linkLast(e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 当前last节点</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;    <span class="hljs-comment">// 创建新节点，prev节点指向当前last节点</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 新节点作为新的last节点</span>    last = newNode;    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)      <span class="hljs-comment">// 如果原last节点为null，表示该链表为空，则将节点同时作为first节点</span>      first = newNode;    <span class="hljs-keyword">else</span>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原last节点的next节点</span>      l.next = newNode;    <span class="hljs-comment">// 元素数量+1</span>    size++;    <span class="hljs-comment">// 集合修改次数+1</span>    modCount++;  &#125;&#125;</code></pre><p>从代码中可以很容易的看出，<code>offer</code>方法直接调用了<code>add</code>方法，<code>add</code>方法中调用了<code>linkLast</code>方法，并直接返回了true，表示该元素肯定可以插入成功。具体执行元素插入的逻辑在<code>linkLast</code>方法中完成，通过上面代码中的注释可以看出，<code>linkLast</code>方法主要功能是在链表尾端添加一个新节点，具体操作示意图如下：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210725224743091.png" alt="image-20210725224743091"></p><p><strong><code>offerFirst</code>和<code>offerLast</code>是如何实现的？</strong></p><p>当了解了<code>offer</code>方法后，我们再看下<code>offerFirst</code>和<code>offerLast</code>的实现。从下面代码中可以知道，<code>offerFirst</code>和<code>offerLast</code>方法分别调用了<code>addFirst</code>和<code>addLast</code>方法，然后在<code>addFirst</code>和<code>addLast</code>方法中，又分别调用了<code>linkFirst</code>和<code>linkLast</code>方法。</p><p><code>linkLast</code>方法上已经讲到，主要功能是在链表尾端添加一个新节点；而<code>linkFirst</code>方法，其主要功能是在链表首端添加一个新节点，具体逻辑与<code>linkLast</code>方法类似，本处不再赘述，可以参考下面代码中的注释。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123;  <span class="hljs-comment">// 队首插入元素</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span> </span>&#123;    addFirst(e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 队尾插入元素</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span> </span>&#123;    addLast(e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 队首插入元素</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;linkFirst(e);  &#125;  <span class="hljs-comment">// 队尾插入元素</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;    linkLast(e);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 在链表头部，添加一个新元素，并作为新的first节点</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 当前first节点</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;    <span class="hljs-comment">// 创建新节点，next节点指向当前first节点</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);    <span class="hljs-comment">// 新节点作为新的first节点</span>    first = newNode;    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)      <span class="hljs-comment">// 如果原first节点为null，表示该链表为空，则将节点同时作为last节点</span>      last = newNode;    <span class="hljs-keyword">else</span>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原first节点的prev节点</span>      f.prev = newNode;    <span class="hljs-comment">// 元素数量+1</span>    size++;    <span class="hljs-comment">// 集合修改次数+1</span>    modCount++;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 本处省略，详见上一代码块</span>  &#125;&#125;</code></pre><p>OK，至此我们已经了解了元素是如何插入的，并且分别介绍了双端队列中在队首和队尾插入元素的实现逻辑，下面我们再简单看下元素是如何实现删除的。</p><h3 id="3-3-元素的删除"><a href="#3-3-元素的删除" class="headerlink" title="3.3  元素的删除"></a>3.3  元素的删除</h3><p>前面了解了元素的插入流程，我们再看删除流程就很清晰了，主要功能就是将队列头或者队尾的节点删除。删除节点的方法主要有<code>poll</code>和<code>pollFirst</code>和<code>pollLast</code>，以及<code>delete</code>、<code>deleteFirst</code>和<code>deleteLast</code>。这几个方法最终调用的都是两个链表的操作方法<code>unlinkFirst</code>和<code>unlinkLast</code>，表示删除链表头部和链表尾部的节点。</p><p>下面是<code>unlinkFirst</code>和<code>unlinkLast</code>方法的代码逻辑，此处不再赘述，可以直接看代码注释。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123; <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除链表头结点f，f不为空</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;        <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span>        <span class="hljs-comment">// 获取头结点的元素</span>        <span class="hljs-keyword">final</span> E element = f.item;        <span class="hljs-comment">// 获取头结点的next结点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;        f.item = <span class="hljs-keyword">null</span>;        f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>        <span class="hljs-comment">// 将next结点作为头结点</span>        first = next;        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">// next结点为null，表示删除完成后链表为空，则last结点置为null</span>            last = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">// 删除完成后链表非空，则当前头结点的prev结点为null</span>            next.prev = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 元素数量-1</span>        size--;        <span class="hljs-comment">// 集合修改次数-1</span>        modCount++;        <span class="hljs-comment">// 返回删除结点的元素</span>        <span class="hljs-keyword">return</span> element;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除链表尾结点l，l不为空</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;        <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span>        <span class="hljs-comment">// 获取尾结点的元素</span>        <span class="hljs-keyword">final</span> E element = l.item;        <span class="hljs-comment">// 获取尾结点的prev结点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;        l.item = <span class="hljs-keyword">null</span>;        l.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>        <span class="hljs-comment">// 将prev结点作为尾结点</span>        last = prev;        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">// prev结点为null，表示删除完成后链表为空，则first结点置为null</span>            first = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">// 删除完成后链表非空，则当前尾结点的next结点为null</span>            prev.next = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 元素数量-1</span>        size--;        <span class="hljs-comment">// 集合修改次数-1</span>        modCount++;        <span class="hljs-comment">// 返回删除结点的元素</span>        <span class="hljs-keyword">return</span> element;    &#125;  &#125;</code></pre><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文主要介绍了Java中Queue的基础用法以及相关底层原理，使用Queue我们可以实现一些任务排队处理的功能等。</p><p>但是在上面分析过程中，我们可以发现Java中Queue的实现其实是<strong>非线程安全</strong>的，如果在多线程环境下进行Queue的入队和出队操作，势必会产生不一致的情况。所以Java也提供了线程安全的队列类——阻塞队列<code>BlockingQueue</code>，我们下文将会对<code>BlockingQueue</code>进行分析。</p><hr><blockquote><p><strong>我是「 毛与帆 」，如果本文对你有帮助，欢迎向各位小伙伴点赞、评论和关注，感谢各位老铁，我们下期见</strong></p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="mp_white"></p>]]></content>
    
    
    <categories>
      
      <category>深入理解Java系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java系列 | 如何搭建JDK源码阅读环境</title>
    <link href="/2021/001-java-src-env/"/>
    <url>/2021/001-java-src-env/</url>
    
    <content type="html"><![CDATA[<blockquote><p> Hi 大家好，我是「 毛与帆 」，一个热爱技术的后端工程师，感谢你的关注！</p></blockquote><p><img src="../../images/cover/001-java-src-env.png" alt="image-20210727215226617"></p><p>从本文开始，我将会跟大家一起回顾Java中的重点知识点，也就是深入理解Java系列，在这个系列中将会带来一系列重点类库的使用、原理分析等内容。</p><p>本文我先介绍一下如何搭建JDK的源码阅读环境，以便更好阅读源码，理解底层的原理，现在开始吧！</p><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>首先，我们需要在IDEA中创建一个Java项目，<code>File - new - project</code>，如下图所示，然后一路next完成项目创建即可；</p><p>在这里，我使用的是java8的源码</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724212801634.png" alt="image-20210724212801634"></p><p>这时候，我们在项目的<code>src</code>目录下，分别创建两个包<code>java</code>和<code>test</code>，用来存放java源码以及我们自己的测试代码。如下图所示：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724213313964.png" alt="image-20210724213313964"></p><h2 id="2-添加Java源码"><a href="#2-添加Java源码" class="headerlink" title="2. 添加Java源码"></a>2. 添加Java源码</h2><p>其实Java的源码获取也非常简单，我们找到自己的jdk安装的路径，在目录下，有一个<code>src.zip</code>压缩文件，这个文件里面就是所有的java源码</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724213455934.png" alt="image-20210724213455934"></p><p>我们将该文件解压到刚才创建的java目录下，如下：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724214007235.png" alt="image-20210724214007235"></p><h2 id="3-几个小配置"><a href="#3-几个小配置" class="headerlink" title="3. 几个小配置"></a>3. 几个小配置</h2><h3 id="3-1-源码文件路径配置"><a href="#3-1-源码文件路径配置" class="headerlink" title="3.1 源码文件路径配置"></a>3.1 源码文件路径配置</h3><p>首先，进入到<code>Project Structure</code>设置里面，如下所示</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724214034085.png" alt="image-20210724214034085"></p><p>然后进入<code>SDKs</code>的配置中，新创建一个java1.8的sdk，点击<code>Sourcepath</code>，这里配置的是java源码地址，我们需要将该压缩文件删掉，然后设置为解压后的目录</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724214925867.png" alt="image-20210724214925867"></p><p>设置为新的目录：</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724215005934.png" alt="image-20210724215005934"></p><p>然后，在<code>Classpath</code>配置中，添加jdk目录下<code>lib/tools.jar</code>文件</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724220624016.png" alt="image-20210724220624016"></p><p>然后，在<code>Project</code>的配置中，<code>Project SDK</code>选择刚创建的<code>1.8-src</code></p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724215055121.png" alt="image-20210724215055121"></p><h3 id="3-2-堆大小设置"><a href="#3-2-堆大小设置" class="headerlink" title="3.2 堆大小设置"></a>3.2 堆大小设置</h3><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724215909362.png" alt="image-20210724215909362"></p><h3 id="3-3-单步调试设置"><a href="#3-3-单步调试设置" class="headerlink" title="3.3 单步调试设置"></a>3.3 单步调试设置</h3><p>由于IDEA限制了单步调试，无法进入java的源码，所以需要修改如下<code>Debugger - Stepping</code>配置，<code>Do not step into the classes</code>选项设置为不勾选</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724215643081.png" alt="image-20210724215643081"></p><h2 id="4-单元测试"><a href="#4-单元测试" class="headerlink" title="4. 单元测试"></a>4. 单元测试</h2><p>这时候，在<code>test</code>目录下，创建一个测试类，如下：点击<code>ArrayList</code>，则可以正常跳转到源码文件，而且，该文件是可以修改的，可以在上面添加注释等</p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724215432316.png" alt="image-20210724215432316"></p><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/image-20210724215419048.png" alt="image-20210724215419048"></p><p>然后可以点击编译运行，在编译运行时，会出现<code>com.sun.java.swing</code>目录下缺失依赖包<code>UNIXToolkit</code>的错误，可以选择将<code>com.sun.java.swing</code>包从项目中删除的方式解决该问题。（swing包下的代码暂时不影响我们源码分析，可以暂时移除；也可以手动添加缺失的几个文件，大家可以自行搜索相关资料解决）。</p><pre><code class="hljs java">java: 找不到符号  符号:   类 UNIXToolkit  位置: 程序包 sun.awt</code></pre><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>OK，到此项目搭建完成了，我们可以愉快的阅读JDK的源码。</p><hr><blockquote><p><strong>我是「 毛与帆 」，如果本文对你有帮助，欢迎向各位小伙伴点赞、评论和关注，感谢各位老铁，我们下期见</strong></p></blockquote><p><img src="https://gitee.com/FrankJiang92/blog-img/raw/master/blog/2021/08/mp_white-1629728084395.png" alt="mp_white"></p>]]></content>
    
    
    <categories>
      
      <category>深入理解Java系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记 | 创新者的窘境</title>
    <link href="/2020/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%88%9B%E6%96%B0%E8%80%85%E7%9A%84%E7%AA%98%E5%A2%83/"/>
    <url>/2020/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%88%9B%E6%96%B0%E8%80%85%E7%9A%84%E7%AA%98%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文为读书笔记，内容均摘抄自《创新者的窘境》</p>          </div><h2 id="创新者的窘境"><a href="#创新者的窘境" class="headerlink" title="创新者的窘境"></a>创新者的窘境</h2><p><code>克莱顿· 克里斯坦森</code> <code>137个笔记</code></p><p><img src="/images/books/%E5%88%9B%E6%96%B0%E8%80%85%E7%9A%84%E7%AA%98%E5%A2%83.jpg"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li> 正如我们所看到的那样，在遇到破坏性技术变革和市场结构变化时，遭遇失败的领先企业数量非常多。</li></ul><h3 id="为什么良好的管理可能会导致失败"><a href="#为什么良好的管理可能会导致失败" class="headerlink" title="为什么良好的管理可能会导致失败"></a>为什么良好的管理可能会导致失败</h3><ul><li><p> 大多数新技术都会推动产品性能的改善，我将这些技术称为“延续性技术”。一些延续性技术可能不具有连续性，或者在本质上具有突破性，而其他一些则在本质上属于渐进式技术。</p></li><li><p> 所有的延续性技术所具有的共同点就是，它们都是根据主要市场的主流客户一直以来所看重的性能层面，来提高成熟产品的性能。</p></li><li><p> 本书所揭示的一项重要发现就是，即使是最具突破性、最复杂的延续性技术，也很少会导致领先企业失败。</p></li><li><p> 破坏性技术给市场带来了与以往截然不同的价值主张。一般来说，破坏性技术产品的性能要低于主流市场的成熟产品，但它们拥有一些边缘客户（通常也是新客户）所看重的其他特性。基于破坏性技术的产品通常价格更低、性能更简单、体积更小，而且通常更便于客户使用。</p></li><li><p> 供应商通常会“过度满足”市场的需求：他们为客户提供的产品，超出了客户的实际需求或客户最终愿意支付的价格（如图1所示）。而且更重要的是，这意味着，尽管目前破坏性技术产品的性能可能低于市场用户的需求，但这种技术日后可能会发展成为同一市场上完全具备性能竞争力的技术。</p></li><li><p> [插图]图1 延续性技术和破坏性技术变革的影响</p></li><li><p> 失败框架的最后一个元素（即成熟企业得出的结论——积极投资破坏性技术对它们来说并不是一个合理的财务决策）有三个基础。首先，破坏性产品功能更简单、价格更便宜，这些产品的利润率通常较低，也不会带来更大的利润；其次，破坏性技术通常在新兴市场或不太重要的市场首先进行商业化运作；再次，能给领先企业带来最大利润的客户一般并不需要，而且确实在开始阶段也无法使用基于破坏性技术的产品。一般来说，破坏性技术首先会得到市场上不能给企业带来利润的那部分客户的认可。</p></li></ul><h3 id="利用破坏性创新的原则"><a href="#利用破坏性创新的原则" class="headerlink" title="利用破坏性创新的原则"></a>利用破坏性创新的原则</h3><ul><li><p> 原则一：企业的资源分布取决于客户和投资者</p></li><li><p> 尽管管理者可能认为是他们在控制企业内部的资源流向，但最终真正决定资源流向的实际上是客户和投资者，因为投资模式无法达到客户和投资者的要求的企业将难以为继。</p></li><li><p> 原则二：小市场并不能解决大企业的增长需求</p></li><li><p> 原则三：无法对并不存在的市场进行分析</p></li><li><p> 许多实例表明，在延续性创新中保持领先地位（预先了解哪些信息是已知的，哪些计划是可行的），这并不会对市场竞争格局产生重大影响。在延续性创新中，技术的跟随者能够表现得和技术领先者一样出色。但就是在面对破坏性创新时（我们会发现我们对这一市场几乎一无所知），先进入市场的企业可以建立起巨大的先发优势。这就是创新者的窘境。</p></li><li><p> 原则四：机构的能力决定了它的局限性</p></li><li><p> 原则五：技术供应可能并不等同于市场需求</p></li><li><p> 当两种或两种以上竞争性产品的性能改善幅度超出了市场需求时，客户将不再能够根据产品的性能来更好地做出购买选择。选择产品的基础通常是从功能性演变至可靠性，然后再发展到便捷性，最后发展到价格。</p></li><li><p> 产品性能过度满足市场需求，是推动产品生命周期发生转变的主要机制。</p></li></ul><h3 id="发现破坏性威胁和机遇的经验教训"><a href="#发现破坏性威胁和机遇的经验教训" class="headerlink" title="发现破坏性威胁和机遇的经验教训"></a>发现破坏性威胁和机遇的经验教训</h3><ul><li> 但电动汽车的确是一种破坏性技术，而且是未来一个潜在的威胁，创新者的使命，是在不影响能够带来利润和增长的现有客户需求的情况下，确保这一创新（目前还不具实际意义的破坏性技术）在企业内部得到足够的重视。</li></ul><h3 id="延续性技术变革"><a href="#延续性技术变革" class="headerlink" title="延续性技术变革"></a>延续性技术变革</h3><ul><li> 其中一些技术创新是较为直观的技术改善，其他则是突破式的技术飞跃</li></ul><h3 id="在破坏性技术创新来临时遭遇失败"><a href="#在破坏性技术创新来临时遭遇失败" class="headerlink" title="在破坏性技术创新来临时遭遇失败"></a>在破坏性技术创新来临时遭遇失败</h3><ul><li><p> 破坏性创新并不能为主流市场的客户提供更好的产品，因此这种创新首先发生在主流市场的可能性很小。</p></li><li><p> [插图]</p></li><li><p> 因此，这些生产8英寸硬盘的新兴企业，将具有“市场破坏性”的硬盘销往一个全新的应用领域——微型计算机[插图]市场。</p></li><li><p> 在解释成熟企业为什么会延迟推出新技术时，经常被提到的一个解释是：担心现有产品的销售受到影响。</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p> 第1种模式是技术上较为简单直接的破坏性创新。</p></li><li><p> 第2种创新模式是，硬盘产业开发先进技术的目的，总是为了延续产品性能改善的固有轨道，以实现更好的性能和更高的利润率</p></li><li><p> 第3种创新模式表明，尽管成熟企业在引领延续性创新方面（包括从最简单到最具突破性的延续性创新）拥有技术上的优势，但在开发和应用破坏性技术方面，引领行业潮流的却总是行业新兴企业。</p></li><li><p> 为新产品找到新的应用领域和新的市场，似乎是这些企业在刚刚进入市场时所普遍具备，但在时过境迁后又明显丧失了的一种能力。这些领先企业似乎被它们的客户牵绊住了手脚，从而在破坏性技术出现时，给了具有攻击性的新兴企业颠覆它们领先地位的可乘之机。</p></li></ul><h3 id="第2章-价值网络和创新推动力"><a href="#第2章-价值网络和创新推动力" class="headerlink" title="第2章 价值网络和创新推动力"></a>第2章 价值网络和创新推动力</h3><ul><li> 价值网络的概念（即一种大环境，企业正是在这个大环境下确定客户的需求，并对此采取应对措施，解决问题，征求客户的意见，应对竞争对手，并争取利润最大化）是这一综合理论的核心。在价值网络内，每一家企业的竞争策略，决定了它对新技术的经济价值的理解。</li></ul><h3 id="能力和突破式技术可能是一种解释"><a href="#能力和突破式技术可能是一种解释" class="headerlink" title="能力和突破式技术可能是一种解释"></a>能力和突破式技术可能是一种解释</h3><ul><li><p> 支持这一观点的学者发现，成熟企业一般善于改善业已成熟的技术，而新兴企业似乎更善于利用突破性新技术，原因通常是它们将已经研发和采用过的技术从一个行业引入另一个行业。</p></li><li><p> 当技术变革破坏了企业以前培养的能力价值时，企业将会遭遇失败；而当新技术提升了企业一直在发展的能力价值时，它们则会取得成功。</p></li></ul><h3 id="价值网络和对导致失败的各种因素的新看法"><a href="#价值网络和对导致失败的各种因素的新看法" class="headerlink" title="价值网络和对导致失败的各种因素的新看法"></a>价值网络和对导致失败的各种因素的新看法</h3><ul><li><p> 在成熟企业中，预期回报反过来将推动资源流向延续性创新，而不是流向破坏性创新。</p></li><li><p> [插图]</p></li><li><p> 每个价值网络成本结构的特点，都会影响企业对具有获利潜力的创新项目的判断。从本质上说，在企业价值网络内受到重视，或发生在基本毛利率较高的价值网络内的创新，将被视为是有利可图的创新。另一方面，那些因为属性方面的原因，只有在毛利率更低的价值网络内才能显示出其价值的技术，则不会被认为是有利可图的创新，而且也不太可能获得各种资源或引起管理者的兴趣。</p></li><li><p> 总而言之，技术机遇的吸引力和制造商在利用这一机遇时将会遇到的困难程度，是由该企业在相关价值网络中所处的位置，以及其他诸多因素决定的。</p></li></ul><h3 id="技术S形曲线和价值网络"><a href="#技术S形曲线和价值网络" class="headerlink" title="技术S形曲线和价值网络"></a>技术S形曲线和价值网络</h3><ul><li><p> [插图]图2.5 常规技术S形曲线</p></li><li><p> 战略性技术管理的本质就是，判断当前的技术S形曲线何时将通过拐点，同时确认并发展任何自下游兴起，并将最终取代现有方法的新技术。</p></li><li><p> [插图]图2.6 破坏性技术S形曲线</p></li></ul><h3 id="管理决策过程和破坏性技术变革"><a href="#管理决策过程和破坏性技术变革" class="headerlink" title="管理决策过程和破坏性技术变革"></a>管理决策过程和破坏性技术变革</h3><ul><li><p> 优秀的管理者只做对企业有意义的事情，而什么是有意义的事情，则由企业所处的价值网络来决定。</p></li><li><p> 8英寸硬盘项目并没有得到太多的重视，负责这一项目开发的工程师不断被抽调去解决14英寸硬盘所出现的问题，因为14英寸硬盘是为更重要的客户群而设计的。</p></li><li><p> 尽管这通常意味着研发费用的增加，但相对于对破坏性技术的投资，这种延续性投资的风险似乎要小得多，因为客户是现成的，客户需求也是已知的。</p></li><li><p> 为了开发破坏性产品结构，新企业纷纷成立，这其中通常还包括在成熟企业中郁郁不得志的工程师所创立的新企业。</p></li></ul><h3 id="闪存和价值网络"><a href="#闪存和价值网络" class="headerlink" title="闪存和价值网络"></a>闪存和价值网络</h3><ul><li><p> 技术S形曲线经常被用于预测新兴技术是否可能取代成熟技术。引发走势变化的是成熟技术曲线的斜率。如果曲线经过了拐点，它的二阶导数为负（技术的改善幅度正在下降），那么新技术可能会出现，并取代成熟技术。</p></li><li><p> 价值网络表明，技术S形曲线只能有效地预测延续性技术。破坏性技术一般与成熟技术呈平行发展态势，两者的发展轨道并不相交。</p></li><li><p> 这并不是因为这项技术太过复杂，也不是因为它们的组织结构妨碍了技术的有效开发，而是因为，它们将把更多的资源用于争夺和维护在当前能够实现赢利的主流硬盘价值网络内的大量业务。</p></li></ul><h3 id="价值网络体系对创新的意义"><a href="#价值网络体系对创新的意义" class="headerlink" title="价值网络体系对创新的意义"></a>价值网络体系对创新的意义</h3><ul><li><p> 价值网络详细说明并界定了价值网络内的企业能做与不能做的事情及其范围。</p></li><li><p> 本章最后针对技术变革的性质和成熟企业所面临的问题，从价值网络的角度总结出了5项建议。</p></li><li><p> 1.企业参与竞争的环境或价值网络，对于它利用和集中必要资源的能力、克服新技术冲击和组织障碍的能力具有深远的影响。</p></li><li><p> 2.决定创新能否取得商业化成功的一项关键因素是，创新能在何种程度上满足价值网络内已知参与者的已知需求。</p></li><li><p> 3.倘若成熟企业决定忽略无法解决当前客户需求的技术，当两条本来井水不犯河水的轨线最终交汇时，这个决定将给它们造成致命的打击。</p></li><li><p> 是因为技术的进步，已经缩小了不同价值网络内相关性能属性排序的差距。</p></li><li><p> 4.在那些颠覆或重新定义了已有技术轨线的发展水平、速度和方向的创新中——从本质上说通常是没有涉及太多新技术的新产品结构创新——新兴企业相对于成熟企业，更具有冲击者的优势，因为这些技术在成熟价值网络内不会创造任何价值。</p></li><li><p> “成熟企业面临的最大障碍就是它们缺乏这么做的意愿。”</p></li><li><p> 5.在这些案例中，尽管“冲击者的优势”与破坏性技术变革有关，但冲击者的优势的本质在于，相对于成熟企业，新兴企业能够轻易地做出判断，灵活地制订战略计划来冲击成熟价值网络，并发展新兴市场应用领域或新的价值网络。</p></li><li><p> 这些观点为分析技术创新提供了新思路。除新技术和创新机构所具有的必备能力外，面临破坏性技术创新的企业必须分析创新对其相关价值网络的影响。关键问题是，那些在创新活动中尚未明确的性能属性，在新兴企业已经建立的价值网络中是否能得到重视；为了实现创新的价值，企业是否必须进入其他价值网络，或建立新的价值网络；市场和技术轨线是否可能最终交汇，从而使无法解决客户当前需求的技术，最终能够解决他们在未来的需求。</p></li></ul><h3 id="成熟挖掘机制造商为应对液压技术采取的措施"><a href="#成熟挖掘机制造商为应对液压技术采取的措施" class="headerlink" title="成熟挖掘机制造商为应对液压技术采取的措施"></a>成熟挖掘机制造商为应对液压技术采取的措施</h3><ul><li> 在大多数破坏性创新案例中都可以看到这种战略选择——成熟企业致力于在成熟市场引入破坏性技术，而成功的新兴企业则发现了一个看重这种技术的新市场。</li></ul><h3 id="液压技术的崛起所产生的结果和影响"><a href="#液压技术的崛起所产生的结果和影响" class="headerlink" title="液压技术的崛起所产生的结果和影响"></a>液压技术的崛起所产生的结果和影响</h3><ul><li><p> 但在竞争的白热化阶段，破坏性技术管理所面临的窘境是，这些企业内部并没有出现任何问题；它们的客户并不需要液压技术，而且确实也不会使用液压技术。</p></li><li><p> 实际上，这也是破坏性技术会使创新者陷入窘境的原因。更努力地工作，更聪明地管理，更积极地投资，更认真地听取客户的建议，这些都是应对新型延续性技术所带来的问题的解决之道。但这些经营原则在应对破坏性技术时却完全失效，而且在很多情况下甚至还会造成反效果。</p></li></ul><h3 id="价值网络和典型的成本结构"><a href="#价值网络和典型的成本结构" class="headerlink" title="价值网络和典型的成本结构"></a>价值网络和典型的成本结构</h3><ul><li><p> 那么导致这种非对称流动的原因到底是什么呢？正如我们之前已经探讨过的那样，这种流动是由资源分配过程推动的，资源分配过程总是推动资源流向能够带来更高利润率和进入更大规模市场的新产品提案。</p></li><li><p> 高端市场的毛利率明显更高，也使制造商对这些业务的投入（这些业务一般都需要更大的成本）获得了回报。</p></li><li><p> 理性的资源分配流程，就是推动企业跨越硬盘行业价值网络的界限不断向上流动，同时限制企业向下流动的根本原因。</p></li></ul><h3 id="资源分配和向上迁移"><a href="#资源分配和向上迁移" class="headerlink" title="资源分配和向上迁移"></a>资源分配和向上迁移</h3><ul><li><p> 我们可以通过比较描述资源如何分配的两种不同模型，进一步理解各个价值网络中的这种非对称性流动。第1个模型将资源分配描述为一种理性的、自上而下的决策制订过程。</p></li><li><p> 第2种资源分配模型首先由约瑟夫·鲍尔提出，他描述的资源分配决策方式完全不同。鲍尔提到，大多数创新提议都是由企业中低层人员而非高层管理者提出。</p></li><li><p> 在争夺资源的博弈中，以现有客户的明确需求为目标，或者以竞争对于目前还无法满足的现有客户的需求为目标的项目，总是能压倒为尚不存在的市场开发产品的提案。</p></li><li><p> 这一非对称问题中最让人困惑的是——最理想的增长和赢利捷径是向上流动，最致命的冲击却来自于低端市场——更加努力地工作，更加聪明地管理，更具前瞻性地规划等“良好的”管理因素均无法解决这一问题。</p></li><li><p> 管理者很难要求有能力的员工持续、积极地从事一些他们认为没有意义的工作。</p></li></ul><h3 id="小型钢铁厂薄板坯连铸连轧技术"><a href="#小型钢铁厂薄板坯连铸连轧技术" class="headerlink" title="小型钢铁厂薄板坯连铸连轧技术"></a>小型钢铁厂薄板坯连铸连轧技术</h3><ul><li> 与硬盘和机械挖掘机领先供应商一样，综合性钢铁企业也同样面临着创新者的窘境：良好的管理决策正是导致它们从行业龙头地位落马的根本原因。</li></ul><h3 id="第二部分-管理破坏性技术变革"><a href="#第二部分-管理破坏性技术变革" class="headerlink" title="第二部分 管理破坏性技术变革"></a>第二部分 管理破坏性技术变革</h3><ul><li><ol><li>资源依赖性：在经营状况良好的企业，客户有效地控制了资源分配模式。</li></ol></li></ul><ol start="2"><li>小市场并不能解决大企业的增长需求。</li><li>破坏性技术的最终用户或应用领域是无法预知的。失败是通往成功的必经之路。</li><li>一个机构的能力独立于机构内部工作人员的能力而存在。一个机构的能力体现在其流程和价值观中，而且正是构成当前业务模式核心能力的流程和价值观，决定了它们无力应对市场的破坏性变化。</li><li>技术供应可能并不等同于市场需求。导致破坏性技术在成熟市场不具吸引力的特性，往往就是构成破坏性技术在新兴市场上的最大价值的特性。</li></ol><h3 id="第5章-把开发破坏性技术的职责赋予存在客户需求的机构"><a href="#第5章-把开发破坏性技术的职责赋予存在客户需求的机构" class="headerlink" title="第5章 把开发破坏性技术的职责赋予存在客户需求的机构"></a>第5章 把开发破坏性技术的职责赋予存在客户需求的机构</h3><ul><li><p> 在实际操作中，真正对哪些能做、哪些不能做有决定权的是企业的客户</p></li><li><p> 特别是表明了这样的理念：成功企业以客户为导向的资源分配和决策流程，在决定投资方向方面所发挥的作用要远远高于管理者的决策。</p></li></ul><h3 id="创新和资源分配"><a href="#创新和资源分配" class="headerlink" title="创新和资源分配"></a>创新和资源分配</h3><ul><li><p> 高层管理者通常只是看到了一个经过层层筛选的创新想法的集合。</p></li><li><p> 与之密切相关的是他们对这些决定（即他们将支持哪些项目提案）将如何影响自身在企业内的职业发展前途的看法，而这一看法又在很大程度上取决于他们对客户需要什么，企业为获得更大利润应该销售什么类型的产品的理解。当他们提出的创新计划给企业创造了极高的利润时，他们的个人职业发展也将得到一个质的飞跃。因此，正是通过这些追求企业利润和个人发展的机制，客户才能在大多数企业的资源分配流程和创新模式中发挥如此重大的影响。</p></li></ul><h3 id="破坏性技术和资源依赖理论"><a href="#破坏性技术和资源依赖理论" class="headerlink" title="破坏性技术和资源依赖理论"></a>破坏性技术和资源依赖理论</h3><ul><li> 为什么在这些行业的破坏性技术变革中成功确立优势地位的企业，只能是那些利用了而不是违背了资源依赖理论原理的企业</li></ul><h3 id="第6章-如何使机构与市场的规模相匹配"><a href="#第6章-如何使机构与市场的规模相匹配" class="headerlink" title="第6章 如何使机构与市场的规模相匹配"></a>第6章 如何使机构与市场的规模相匹配</h3><ul><li> 由于成长型企业每年需要大幅提高收入水平，才能维持它们所期望的增长率，因此，作为一种增长手段，这些企业越来越不可能通过小型市场来获取其所希望的这部分新收入。</li></ul><h3 id="企业规模和破坏性技术变革中的领先地位"><a href="#企业规模和破坏性技术变革中的领先地位" class="headerlink" title="企业规模和破坏性技术变革中的领先地位"></a>企业规模和破坏性技术变革中的领先地位</h3><ul><li> 增长率会对企业的股价产生重大影响。从某种程度上说，企业的股价代表了一些市场预测的企业未来赢利流的贴现现值，然后股价的水平（不管是上涨还是下跌）会受到预期赢利增长率变化的影响</li></ul><h3 id="案例研究：推动新兴市场的增长率"><a href="#案例研究：推动新兴市场的增长率" class="headerlink" title="案例研究：推动新兴市场的增长率"></a>案例研究：推动新兴市场的增长率</h3><ul><li> 但我们认为，导致苹果公司在这个项目上遭遇失败的根本原因并不是管理不当。公司高管的行为揭示了一个更深层次的问题：小市场并不能满足大机构的短期增长需求。</li></ul><h3 id="案例研究：让小机构去利用小机遇"><a href="#案例研究：让小机构去利用小机遇" class="headerlink" title="案例研究：让小机构去利用小机遇"></a>案例研究：让小机构去利用小机遇</h3><ul><li> 指望那些希望在大企业一展宏图的员工全力支持（包括利用他们所掌握的资源，并付出巨大的时间和精力）规模较小、市场定位不明确的破坏性项目，无异于古人手缚羽翼、挥动翅膀的飞行痴梦。</li></ul><h3 id="第7章-发现新的市场"><a href="#第7章-发现新的市场" class="headerlink" title="第7章 发现新的市场"></a>第7章 发现新的市场</h3><ul><li> 尚不存在的市场是无法分析的，因此，管理者为应对破坏性技术变革而采取的战略和计划应该是有关学习和发现的计划，而不是事关执行的计划。</li></ul><h3 id="成熟企业面临的不可预见性和向下游市场移动的难度"><a href="#成熟企业面临的不可预见性和向下游市场移动的难度" class="headerlink" title="成熟企业面临的不可预见性和向下游市场移动的难度"></a>成熟企业面临的不可预见性和向下游市场移动的难度</h3><ul><li><p> 在所有有关破坏性技术的不确定因素中，管理者总是可以遵循这样一条法则，即专家的预测总是错误的。</p></li><li><p> 由于失败是为破坏性技术寻找新市场的必经之路，管理者不能或者不愿拿他们的个人职业生涯来做赌注的事实，也构成了一股强大的阻力，妨碍了成熟企业进入由这些技术创造的价值网络。</p></li><li><p> 来自市场的压力使犯错的概率和成本都有所降低。</p></li><li><p> 我将这种发现破坏性技术新兴市场的方法命名为“不可知营销”。根据这种方法进行市场营销，必须遵循这样一个明确的假设，即：没有人——不论是我们，还是我们的客户——能够在真正使用之前了解破坏性产品是否能够投入使用，怎样使用，或者使用量有多大。</p></li></ul><h3 id="第8章-如何评估机构的能力与缺陷"><a href="#第8章-如何评估机构的能力与缺陷" class="headerlink" title="第8章 如何评估机构的能力与缺陷"></a>第8章 如何评估机构的能力与缺陷</h3><ul><li> 机构本身也具有独立于机构内部人员或其他资源的能力。要想持续获得成功，优秀的管理者就需要掌握足够的技巧。这种技巧不仅仅表现在挑选、培训、激励员工，使能者胜任，还表现在要善于为需要完成的任务选择、创建并筹备适合的机构，使能者适得其所。</li></ul><h3 id="机构能力框架"><a href="#机构能力框架" class="headerlink" title="机构能力框架"></a>机构能力框架</h3><ul><li><p> 机构的能力往往受到3个因素的影响：资源、流程以及价值观。</p></li><li><p> 资源更易于在不同机构间实现转移。毋庸置疑，获取大量的优质资源有助于提高机构应对变革时的胜算。</p></li><li><p> 换句话说，如果某个流程定义了完成某项特定任务的能力，那就等于同时也定义了无法完成其他任务的能力。</p></li><li><p> 企业的价值观就是在确定决策优先级别时所遵循的标准。有些企业的价值观是以道德为基础。</p></li><li><p> 资源–流程–价值观（RPV，Resource-Procedure-Value）</p></li><li><p> 一个企业变得越大越复杂，就越需要高级管理人员来培训各级员工，使他们学会遵照企业的战略方向和业务模式，来自主确定决策的优先级别。事实上，良好管理的一个关键衡量标准就在于，管理者是否在机构内部普及了这种清晰、统一的价值观。</p></li><li><p> 使小企业欢欣鼓舞的市场机遇，对大企业来说可能就形同鸡肋。</p></li><li><p> 成功所带来的效应实则是苦乐参半，当企业不断发展壮大时，它们也基本丧失了进入小型新兴市场的能力。这种能力的缺失并不是由于企业内部的资源发生改变而造成的——一般说来，这类企业往往坐拥庞大资源。问题的关键在于其价值观发生了改变。</p></li></ul><h3 id="流程与价值观的关系，以及如何成功应对延续性技术与破坏性技术"><a href="#流程与价值观的关系，以及如何成功应对延续性技术与破坏性技术" class="headerlink" title="流程与价值观的关系，以及如何成功应对延续性技术与破坏性技术"></a>流程与价值观的关系，以及如何成功应对延续性技术与破坏性技术</h3><ul><li><p> RPV框架（资源、流程、价值观框架）是一个非常实用的工具，有助于了解我在研究各个企业应对延续性技术与破坏性技术的不同历史表现中的有关发现。</p></li><li><p> 领先的硬盘企业所拥有的资源（包括人力、资金以及技术资源）能够保证它们在延续性技术和破坏性技术创新上双管齐下，但这些企业的流程和价值观却决定了它们无法成功地进行破坏性技术创新。</p></li></ul><h3 id="能力的转移"><a href="#能力的转移" class="headerlink" title="能力的转移"></a>能力的转移</h3><ul><li><p> 一旦企业成员开始根据假设，而不是主观判断，来选择工作方式和决策标准，那么这些流程和价值观就将构成企业的文化。</p></li><li><p> 企业文化就成为一个强大的管理工具，能够促使员工自主行动，并确保他们保持行动的统一</p></li><li><p> 决定机构能力和缺陷的最为有力的因素，会随着时间的推移而不断发生变动——从资源变为可预见的、有意识的流程和价值观，然后再转化为文化。</p></li><li><p> 当机构的能力主要体现在人员身上时，通过改革来解决新问题会相对简单，但当能力开始根植于流程和价值观，尤其是当能力已成为机构文化的一部分时，改变可能会变得异常困难。</p></li></ul><h3 id="创造新能力应对变革"><a href="#创造新能力应对变革" class="headerlink" title="创造新能力应对变革"></a>创造新能力应对变革</h3><ul><li><p> 看来财务分析师一般对资源的价值有着良好的直觉，但对于流程的价值的直觉却不尽然。</p></li><li><p> 机构的流程和价值观才是企业最基本的能力。流程和价值观决定了企业将如何整合资源（企业可以购买和出售、使用和放弃许多资源）以创造价值。</p></li><li><p> 分支机构需要享有多大程度的独立性呢？最基本的要求是，分支机构的项目不能被迫去和主流机构的项目争夺资源。</p></li><li><p> 独立机构是否在形式上实现了独立其实并不重要，真正重要的是它是否独立于常规资源分配流程而存在。</p></li><li><p> 企业成立职能型和轻量级团队是拓展现有能力的有效途径，而组建重量级团队则是创造新能力的有力工具。同样，分支机构也是打造新型价值观的工具。</p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li><p> 当机构遭遇变革时，管理者首先必须确定，他们是否具备成功所需的资源。然后，他们需要再问一个不同的问题：机构是否具备成功所需的流程和价值观？</p></li><li><p> 对于成熟企业来说，创新之所以总是看起来困难重重，其原因就在于它们聘用了能力很强的人，并将设计初衷与他们肩负的使命不相匹配的流程和价值观强加给他们。</p></li></ul><h3 id="第9章-产品性能、市场需求和生命周期"><a href="#第9章-产品性能、市场需求和生命周期" class="headerlink" title="第9章 产品性能、市场需求和生命周期"></a>第9章 产品性能、市场需求和生命周期</h3><ul><li> 当产生性能过度供给现象时，破坏性技术的机遇也呼之欲出，然后开始从价值网络的下方冲击成熟市场。</li></ul><h3 id="性能过度供给和竞争基础的变化"><a href="#性能过度供给和竞争基础的变化" class="headerlink" title="性能过度供给和竞争基础的变化"></a>性能过度供给和竞争基础的变化</h3><ul><li> 一般来说，一旦某项特定属性达到了所要求的性能水平，客户便不会再像以前那样愿意为该项属性的持续改善支付溢价，这表明客户对这项属性的需求已经得到满足。</li></ul><h3 id="产品何时演变为商品"><a href="#产品何时演变为商品" class="headerlink" title="产品何时演变为商品"></a>产品何时演变为商品</h3><ul><li> 当产品特色和功能已经超出市场需求时，差异化也就失去了意义。</li></ul><h3 id="性能过度供给和产品竞争的演变"><a href="#性能过度供给和产品竞争的演变" class="headerlink" title="性能过度供给和产品竞争的演变"></a>性能过度供给和产品竞争的演变</h3><ul><li> “购买等级”的产品演变模式。这一模式将产品演变划分为以下4个阶段：功能性、可靠性、便捷性和价格。</li></ul><h3 id="破坏性技术的其他普遍特征"><a href="#破坏性技术的其他普遍特征" class="headerlink" title="破坏性技术的其他普遍特征"></a>破坏性技术的其他普遍特征</h3><ul><li><p> 破坏性技术的其他两项重要特征，可能会对产品生命周期和竞争态势产生长期影响：首先，破坏性产品在主流市场几乎没有价值的属性，通常成为它们在新兴市场最大的卖点；其次，相比成熟产品，破坏性产品一般更简单、更便宜，也更可靠、更便捷。</p></li><li><p> 与之相比，在对破坏性技术的商业开发中做得最成功的企业，是那些将市场营销挑战（构建或发现一个新市场，其中的产品竞争主要围绕着产品的破坏性属性展开）视为它们面临的主要发展挑战的企业。</p></li></ul><h3 id="发生在胰岛素产品生命周期中的性能过度供给"><a href="#发生在胰岛素产品生命周期中的性能过度供给" class="headerlink" title="发生在胰岛素产品生命周期中的性能过度供给"></a>发生在胰岛素产品生命周期中的性能过度供给</h3><ul><li><p> 礼来公司和诺和公司的经验进一步证明，性能超出市场需求的产品将被迫接受与商品层级相同的价格，而重新定义了竞争基础的破坏性产品则可以获得溢价。</p></li><li><p> 在竞争达到白热化时，也许并不会表现得那么明显</p></li><li><p> 主流客户的权力和影响，的确是导致企业的产品开发过度满足主流市场需求的一个主要原因。</p></li></ul><h3 id="正确的战略和错误的战略"><a href="#正确的战略和错误的战略" class="headerlink" title="正确的战略和错误的战略"></a>正确的战略和错误的战略</h3><ul><li> ，那就是不管是有意识的还是出于本能，他们都深刻理解了客户的需求曲线和技术人员的供给曲线。到目前为止，理解这些曲线是他们获得成功的关键。</li></ul><h3 id="第10章-管理破坏性技术变革：案例研究"><a href="#第10章-管理破坏性技术变革：案例研究" class="headerlink" title="第10章 管理破坏性技术变革：案例研究"></a>第10章 管理破坏性技术变革：案例研究</h3><ul><li> 能力不足、官僚作风、傲慢自大、管理队伍老化、规划不合理和投资短视，显然是导致许多企业最终失败的主要原因。</li></ul><h3 id="我们怎样才能判断出某项技术是否具有破坏性"><a href="#我们怎样才能判断出某项技术是否具有破坏性" class="headerlink" title="我们怎样才能判断出某项技术是否具有破坏性"></a>我们怎样才能判断出某项技术是否具有破坏性</h3><ul><li> 只有在我们发现其性能改善曲线在日后有可能会与主流市场的需求相交汇时，我们才能说电动汽车是一种破坏性产品。</li></ul><h3 id="电动汽车的市场到底在哪儿"><a href="#电动汽车的市场到底在哪儿" class="headerlink" title="电动汽车的市场到底在哪儿"></a>电动汽车的市场到底在哪儿</h3><ul><li><p> 我不会去效仿其他汽车制造商，因为我认为，他们的直觉和能力都用在了错误的目标上。</p></li><li><p> 第2项原则就是，没有人能通过市场研究了解到电动汽车的早期市场到底在哪儿</p></li><li><p> 第3项原则是，我的创业计划必须是一个学习的计划，而不是一个实施预先制定的战略的计划。</p></li><li><p> 在破坏性技术发展的初期，主流客户从来都不会选择使用破坏性产品。</p></li></ul><h3 id="我们应采取什么样的产品技术和经销策略"><a href="#我们应采取什么样的产品技术和经销策略" class="headerlink" title="我们应采取什么样的产品技术和经销策略"></a>我们应采取什么样的产品技术和经销策略</h3><ul><li><p> 竞争的基础会随着产品生产周期的变化而发生改变，而变化周期本身则是受到性能过度供给这一现象（即技术所能提供的性能超出了市场的实际需求）的推动。</p></li><li><p> 每一种破坏性技术最初的应用领域都是更加注重简单性和便捷性的新型价值网络。</p></li></ul><h3 id="第11章-创新者的窘境：概要"><a href="#第11章-创新者的窘境：概要" class="headerlink" title="第11章 创新者的窘境：概要"></a>第11章 创新者的窘境：概要</h3><ul><li><p> 第一，市场要求的或者能够消化的发展速度，可能会与技术能够达到的发展速度存在差异。</p></li><li><p> 第二，创新管理反映了资源分配流程。</p></li><li><p> 第三，正如每个创新问题都有资源分配方面的原因一样，市场与技术的匹配是这个问题的另一个方面。</p></li><li><p> 破坏性技术应被看作是一种市场营销挑战，而不是技术性挑战。</p></li><li><p> 第四，尽管不太愿意承认，但大多数机构所具备的能力要比大多数管理者预想的还要细化，还要依赖于具体的环境，因为能力，都是在价值网络内形成的。</p></li><li><p> 第五，在许多情况下，当面对破坏性技术时，进行具有决定性的重大投资并没有可供借鉴的参考信息。</p></li><li><p> 第六，采取一成不变的技术战略（或者永远争当领先者，或者一直甘做追随者）是不明智的。</p></li><li><p> 第七，也是最后一点，本书概述的研究表明，市场准入和市场流动经常会遭遇非常强大的壁垒，而且这种壁垒与经济学家之前定义和关注的壁垒类型存在很大的不同。</p></li></ul><h3 id="阅读指南"><a href="#阅读指南" class="headerlink" title="阅读指南"></a>阅读指南</h3><ul><li><p> 破坏性技术原则</p></li><li><p> 1.企业的资源分布取决于客户和投资者</p></li><li><p> 2.小市场并不能解决大企业的增长需求</p></li><li><p> 3.无法对并不存在的市场进行分析</p></li><li><p> 4.技术供给可能并不等同于市场需求</p></li><li><p> ①将发展破坏性技术的职责交给确实存在客户需求的机构，以便确保资源能够流向这些机构；<br>②设立一个能够欣然接受较小收益的独立的小型机构；</p></li><li><p> ③为失败做好准备。不要在第一次就用尽所有的资源，因为你不可能在第一次尝试中就抓住正确的市场方向。在对破坏性技术进行商业化开发时，将最初的种种努力看作是学习机会，在获得相关数据后做出调整；<br>④不要寄希望于技术突破。尽早开始行动，为破坏性技术的当前属性寻找市场，你将在当前主流市场以外的地方找到它的市场。而且，你还将发现，对主流市场不具吸引力的破坏性技术属性正是建立新兴市场时所依赖的属性。</p></li></ul><h3 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h3><p>点评:★★★★☆</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记 | 一个叫欧维的男人决定去死</title>
    <link href="/2020/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80%E4%B8%AA%E5%8F%AB%E6%AC%A7%E7%BB%B4%E7%9A%84%E7%94%B7%E4%BA%BA%E5%86%B3%E5%AE%9A%E5%8E%BB%E6%AD%BB/"/>
    <url>/2020/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80%E4%B8%AA%E5%8F%AB%E6%AC%A7%E7%BB%B4%E7%9A%84%E7%94%B7%E4%BA%BA%E5%86%B3%E5%AE%9A%E5%8E%BB%E6%AD%BB/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文为读书笔记，内容均摘抄自《一个叫欧维的男人决定去死》</p>          </div><h2 id="一个叫欧维的男人决定去死"><a href="#一个叫欧维的男人决定去死" class="headerlink" title="一个叫欧维的男人决定去死"></a>一个叫欧维的男人决定去死</h2><p><code>弗雷德里克·巴克曼</code> <code>29个想法</code></p><p><img src="/images/books/%E6%AC%A7%E7%BB%B4.jpg"></p><h3 id="1-一个叫欧维的男人买了个不是电脑的电脑"><a href="#1-一个叫欧维的男人买了个不是电脑的电脑" class="headerlink" title="1 一个叫欧维的男人买了个不是电脑的电脑"></a>1 一个叫欧维的男人买了个不是电脑的电脑</h3><ul><li> 又是沉默。跟发生在两个突然发觉自己忘带手枪的枪手之间的那种沉默也没太大差别。</li></ul><h3 id="3-一个叫欧维的男人拉着拖斗倒车"><a href="#3-一个叫欧维的男人拉着拖斗倒车" class="headerlink" title="3 一个叫欧维的男人拉着拖斗倒车"></a>3 一个叫欧维的男人拉着拖斗倒车</h3><ul><li> 欧维总是本能地对所有一米八五以上的人心存怀疑。经验告诉他，长成这样，血液很难抵达大脑。</li></ul><h3 id="4-一个叫欧维的男人不交三克朗增值税"><a href="#4-一个叫欧维的男人不交三克朗增值税" class="headerlink" title="4 一个叫欧维的男人不交三克朗增值税"></a>4 一个叫欧维的男人不交三克朗增值税</h3><ul><li><p> 他注意到天开始凉了起来。快到把蓝色秋季外套换成蓝色冬季外套的时候了。</p></li><li><p> 就像欧维太太常说的那样：“要是有什么值得写进欧维的讣告，那就是‘无论如何，此人还算省油’。”</p></li></ul><h3 id="5-一个叫欧维的男人"><a href="#5-一个叫欧维的男人" class="headerlink" title="5 一个叫欧维的男人"></a>5 一个叫欧维的男人</h3><ul><li><p> 他是个非黑即白的男人。她是色彩，他的全部色彩。</p></li><li><p> 他从来不参与却也从来不逃离，只是简单地存在着。</p></li><li><p> 总经理夫人邀请他留下来参加婚宴，但欧维的父亲悄悄对她说，像他这样小臂上的油渍深得已经等同肤色的人，坐在这些上等人中间不合适，但很乐意带一袋面包和肉回去给家里的小家伙吃，他说。欧维刚满八岁。当晚父亲摆上晚餐的时候，小家伙心想，国王的晚餐一定就是这样的。</p></li><li><p> 人们总说欧维眼里的世界非黑即白，而她是色彩，他的全部色彩。</p></li></ul><h3 id="7-一个叫欧维的男人挂上个钩子"><a href="#7-一个叫欧维的男人挂上个钩子" class="headerlink" title="7 一个叫欧维的男人挂上个钩子"></a>7 一个叫欧维的男人挂上个钩子</h3><ul><li> 或者，说得更贴切一点，她想要这一个房间每半年变一次颜色。她这样对欧维说时，欧维让她别做梦了。于是她打电话找了个粉刷匠，让他报个价。然后她告诉欧维她打算付给粉刷匠多少钱，再然后欧维就起身拿刷子去了。</li></ul><h3 id="8-一个叫欧维的男人和一对父亲的老脚印"><a href="#8-一个叫欧维的男人和一对父亲的老脚印" class="headerlink" title="8 一个叫欧维的男人和一对父亲的老脚印"></a>8 一个叫欧维的男人和一对父亲的老脚印</h3><ul><li><p> “一个人的品质是由他的行为决定的，而不是他说的话。”欧维说。</p></li><li><p> 她常说：“每一条道路最终都会带领你到注定的归宿。”对她来说，注定的或许是“某事”。但对他来说，注定的是“某人”。</p></li></ul><h3 id="9-一个叫欧维的男人给暖气通风"><a href="#9-一个叫欧维的男人给暖气通风" class="headerlink" title="9 一个叫欧维的男人给暖气通风"></a>9 一个叫欧维的男人给暖气通风</h3><ul><li> 这是一个还没过期就已经过时的世界。整个国家都在为没人能正经做事起立鼓掌，毫无保留地为平庸欢呼喝彩。</li></ul><h3 id="12-一个叫欧维的男人有所获"><a href="#12-一个叫欧维的男人有所获" class="headerlink" title="12 一个叫欧维的男人有所获"></a>12 一个叫欧维的男人有所获</h3><ul><li> 每个人的生命中总有那么一刻决定他们将成为什么样的人：是不是愿意让别人骑在头上。你不了解那个故事，就不了解那个人。</li></ul><h3 id="14-一个叫欧维的男人和一个火车上的女人"><a href="#14-一个叫欧维的男人和一个火车上的女人" class="headerlink" title="14 一个叫欧维的男人和一个火车上的女人"></a>14 一个叫欧维的男人和一个火车上的女人</h3><ul><li><p> 他当时当然不知道，他的一生将有多少个一刻钟要用来等待她，要是他父亲知道了，一定会气坏的。但当她身着一条印花长裙和一件红得让欧维不得不挪动一下脚步的羊毛衫出现时，欧维当即决定，她不守时的毛病也可以原谅。</p></li><li><p> 要是有人问起，他会说，在她之前，他没有生活。之后也没有。</p></li></ul><h3 id="16-一个叫欧维的男人和一辆树林里的卡车"><a href="#16-一个叫欧维的男人和一辆树林里的卡车" class="headerlink" title="16 一个叫欧维的男人和一辆树林里的卡车"></a>16 一个叫欧维的男人和一辆树林里的卡车</h3><ul><li> “有人说最优秀的人是从错误中重生的，他们后来通常比那些从没有犯过错误的人更优秀。”</li></ul><h3 id="18-一个叫欧维的男人和一只叫恩斯特的猫"><a href="#18-一个叫欧维的男人和一只叫恩斯特的猫" class="headerlink" title="18 一个叫欧维的男人和一只叫恩斯特的猫"></a>18 一个叫欧维的男人和一只叫恩斯特的猫</h3><ul><li> 现在你得加倍爱我。”她要求道。于是欧维对她撒了谎，说他会的。尽管他心里很清楚，他已经不可能比现在更爱她了。</li></ul><h3 id="23-一个叫欧维的男人和一辆一去不返的公车"><a href="#23-一个叫欧维的男人和一辆一去不返的公车" class="headerlink" title="23 一个叫欧维的男人和一辆一去不返的公车"></a>23 一个叫欧维的男人和一辆一去不返的公车</h3><ul><li><p> 但所到之处，他总在穿白衬衫、表情严峻而自以为是的那些人跟前碰壁。他们不可一世。他们不仅有国家撑腰，他们就是国家。</p></li><li><p> 每个人都必须知道他在为什么奋斗，他们这么说。她为了一切的美好而奋斗，为了她从未降生的孩子，而欧维为了她而奋斗。因为，这世界上，只有她值得他去奋斗。</p></li></ul><h3 id="32-一个叫欧维的男人不开该死的旅馆"><a href="#32-一个叫欧维的男人不开该死的旅馆" class="headerlink" title="32 一个叫欧维的男人不开该死的旅馆"></a>32 一个叫欧维的男人不开该死的旅馆</h3><ul><li><p> “每个人都想有尊严地生活。对不同的人来说，尊严是不同的。”索雅曾说。</p></li><li><p> 对欧维和鲁尼这样的男人来说，尊严只是成年以后可以自力更生，把不需要依靠别人视为自己的权利。掌控中存在一种自豪感，明辨是非的自豪感，知道该走哪条路，知道该不该在哪儿拧上螺丝。欧维和鲁尼这样的人还留在靠行动而不是靠嘴说的年代，索雅总是那么说。</p></li></ul><h3 id="33-一个叫欧维的男人和一次非比寻常的巡逻"><a href="#33-一个叫欧维的男人和一次非比寻常的巡逻" class="headerlink" title="33 一个叫欧维的男人和一次非比寻常的巡逻"></a>33 一个叫欧维的男人和一次非比寻常的巡逻</h3><ul><li> 欧维大概从来就知道自己到底该做什么，但对于时间，所有人都太乐观。我们相信总能腾出时间来与他人一起做想做的事，说想说的话。然后突然有一天，发生了什么意外，我们就只好站在那儿，脑海总盘旋着一个词：如果。</li></ul><h3 id="35-一个叫欧维的男人和社交障碍"><a href="#35-一个叫欧维的男人和社交障碍" class="headerlink" title="35 一个叫欧维的男人和社交障碍"></a>35 一个叫欧维的男人和社交障碍</h3><ul><li> “如果你是记者，就会发现，官僚主义的妙处，在于首先违反官僚制度的总是你们这些官僚自己。”</li></ul><h3 id="36-一个叫欧维的男人和一杯威士忌"><a href="#36-一个叫欧维的男人和一杯威士忌" class="headerlink" title="36 一个叫欧维的男人和一杯威士忌"></a>36 一个叫欧维的男人和一杯威士忌</h3><ul><li><p> “爱上一个人就像搬进一座房子，”索雅曾说，“一开始你会爱上新的一切，陶醉于拥有它的每一个清晨，就好像害怕会有人突然冲进房门指出这是个错误，你根本不该住得那么好。但经年累月房子的外墙开始陈旧，木板七翘八裂，你会因为它本该完美的不完美而渐渐不再那么爱它。然后你渐渐谙熟所有的破绽和瑕疵。天冷的时候，如何避免钥匙卡在锁孔里；哪块地板踩上去的时候容易弯曲；怎么打开一扇橱门又恰好可以不让它嘎吱作响。这些都是会赋予你归属感的小秘密。”</p></li><li><p> 认错很难，特别是错了很久以后。</p></li></ul><h3 id="39-一个叫欧维的男人和死神"><a href="#39-一个叫欧维的男人和死神" class="headerlink" title="39 一个叫欧维的男人和死神"></a>39 一个叫欧维的男人和死神</h3><ul><li><p> 对死亡最大的恐惧，在于它与我们擦肩而过，留下我们独自一人。</p></li><li><p> 时间是一桩奇怪的事情。大多数人只为了未来生活。几天之后，几周之后，或者几年。每个人一生中最恼人的那一刻可能就是突然意识到自己已经到了回忆比展望更多的年龄。当来日无多的时候，必须有别的动力让人活下去。或许是回忆。午后的阳光中牵着某人的手，鲜花绽放的花坛，周日的咖啡馆。或许是孙子孙女。人们为了别人的未来继续生活。索雅离开欧维的时候，他并没有一起死去。他只是不再活着。悲伤是一桩奇怪的事情。</p></li><li><p> 爱是桩奇怪的事情。它来得出其不意。</p></li></ul><h3 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h3><p>★★★★★</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记 | 富爸爸穷爸爸（20周年修订版）</title>
    <link href="/2020/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/"/>
    <url>/2020/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文为读书笔记，内容均摘抄自《富爸爸穷爸爸》</p>          </div><h2 id="富爸爸穷爸爸（20周年修订版）"><a href="#富爸爸穷爸爸（20周年修订版）" class="headerlink" title="富爸爸穷爸爸（20周年修订版）"></a>富爸爸穷爸爸（20周年修订版）</h2><p><code>罗伯特·清崎</code> <code>114个笔记</code></p><p><img src="/images/books/%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8.jpg"></p><h3 id="后见之明-20年后的今天"><a href="#后见之明-20年后的今天" class="headerlink" title="后见之明 20年后的今天"></a>后见之明 20年后的今天</h3><ul><li> 大部分增长的收入都流向企业家及投资者，而并非劳动者——那些为钱而工作的人们。</li></ul><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul><li><p> 一个爸爸会说：“贪财乃万恶之源。”而另一个爸爸却说：“贫穷才是万恶之本。”</p></li><li><p> 我的一个爸爸总是习惯说“我可付不起”，而另一个爸爸则禁止我们说这样的话，他坚持让我这样说：“我怎样才能付得起？”这两句话，一句是陈述句，另一句是疑问句。</p></li><li><p> 贫穷和破产的区别是：破产是暂时的，而贫穷是永久的。</p></li></ul><h3 id="第一课-富人不为钱工作"><a href="#第一课-富人不为钱工作" class="headerlink" title="第一课 富人不为钱工作"></a>第一课 富人不为钱工作</h3><ul><li><p> 穷人和中产阶级为钱而工作。富人让钱为他工作。</p></li><li><p> 如果你不能下定决心，就永远也学不会如何赚钱。机会总是转瞬即逝。知道什么时候要迅速做出决定是一项非常重要的技能。</p></li><li><p> “生活推着我们所有的人，有些人放弃了，有些人在抗争。少数人学会了这门课程，取得了进步，他们欢迎生活来推动他们，对他们来说，这种推动意味着他们需要并愿意去学习一些东西。他们学习，然后取得进步。但大多数人放弃了，还有一部分人像你一样在抗争。”</p></li><li><p> 如果你学会了这门课程，你就会成为一个聪明、富有和快乐的人。如果你没有学会，你就只会终生抱怨工作、低报酬和老板，你终其一生希望有个大机会能够把你所有的钱的问题都解决。”</p></li><li><p> 生活中的很多事情是我们无法控制的。我学会了专注于我所能控制的：我自己。如果事情必须改变，首先要改变的就是我自己。</p></li><li><p> “别担心，你只需知道，正是出于恐惧的心理，人们才想找一份安稳的工作。这些恐惧有：害怕付不起账单，害怕被解雇，害怕没有足够的钱，害怕重新开始。为了寻求保障，他们会学习某种专业，或是做生意，拼命为钱而工作。大多数人成了钱的奴隶，然后就把怒气发泄在他们老板身上。”</p></li><li><p> 人们的生活永远被这两种感觉所控制：恐惧和贪婪。</p></li><li><p> 大多数人都希望有一份工资收入，因为他们都有恐惧和贪婪之心。一开始，没钱的恐惧会促使他们努力工作，得到报酬后，贪婪或欲望又让他们想拥有所有用钱能买到的好东西。于是就形成了一种模式。</p></li><li><p> 所以，他们的感情代替了他们的思想。</p></li><li><p> 钱主宰着他们的生活，他们拒绝去分辨真相，钱控制了他们的情感和灵魂。</p></li><li><p> 很多人说“我对钱没兴趣”，可他们却每天工作8小时。</p></li><li><p> 人生实际上是在无知和觉醒之间的一场斗争。</p></li><li><p> “我可以给你们举一些例子。一个医生，想多挣些钱让家人生活得更好，于是就提高了收费，这就导致人们医疗保健费用的增加。<br>“这极大地损害了穷人的利益，所以穷人的健康状况要比富人差。由于医生提高收费，律师也提高了收费；由于律师提高收费，学校的老师也想增加收入，这就使政府提高了税收。这种循环不断继续下去，不久，在富人和穷人之间就有了一条可怕的鸿沟，不安定就会出现。历史证明当鸿沟大到极点时，一个社会就会崩溃。</p></li><li><p> 所谓的荆棘之路就是指我们的恐惧和贪婪。直面我们的贪婪、弱点和缺陷是唯一的出路。这条路需要你用心去确定你的思想。</p></li><li><p> 工作只是面对长期问题的一种暂时的解决办法。大多数人心里只有一个问题，并且亟待解决，那就是月末要付账了，账单就像那个柏油孩子。钱控制了他们的生活，或者确切地说是对钱的无知和恐惧控制了他们的生活。所以他们就像他们的父母一样，每天起床之后就去工作挣钱，没有时间问问自己：还有什么别的法子吗？他们的思想被他们的感情，而不是他们的头脑控制着</p></li><li><p> 当情感占据上风时，理智就会下降。</p></li><li><p> ‘我失去了什么’，只有这样的话才能让你避免感情用事，并留给你仔细思考的时间。”</p></li><li><p> “继续工作，孩子们，你们越快忘记你们的工资，你们未来的生活就会越轻松，继续用你们的头脑思考，不求回报地工作，很快就会发现比拿工资更挣钱的方法。你们会看到别人看不见的东西。机会就摆在人们面前，但大多数人从来看不到这些机会，因为他们忙着追求金钱和安定，所以只能得到这些。如果你们能看到一个机会，就注定你们会在一生中不断地发现机会。那时，我会教你们其他的事。学会了这些，你们就能避开生活中最大的陷阱。”</p></li></ul><h3 id="讨论学习环节"><a href="#讨论学习环节" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li><p> 对于孩子们来说最主要的还是学会用感情来思考，而不是带着感情去思考。他们必须学会选择他们的想法。</p></li><li><p> 如果你认为问题在你那儿，你就会改变自己，学习一些东西让自己变得更聪明。</p></li><li><p> 大多数人并不知道是他们的感情代替了他们进行思考。工作只是试图用暂时的办法来解决长期的问题。</p></li></ul><h3 id="第二课-为什么要教授财务知识"><a href="#第二课-为什么要教授财务知识" class="headerlink" title="第二课 为什么要教授财务知识"></a>第二课 为什么要教授财务知识</h3><ul><li><p> 我们的财富可以不受通货膨胀的影响，自动增长。资产已经多到可以自我增值，就像种树，你年复一年地浇灌它，终于有一天它不再需要你的照料了。它的根已经长得足够深，你现在可以开始享受它带给你的阴凉了。</p></li><li><p> 只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。</p></li><li><p> 从长远来看，重要的不是你挣了多少钱，而是你能留下多少钱，以及能够留住多久。</p></li><li><p> 富人获得资产，而穷人和中产阶级获得负债，只不过他们以为那些负债就是资产。规则 你必须明白资产和负债的区别，并且购买资产。如果你想致富，这一点你必须知道。这就是第一条规则，也是唯一一条规则。</p></li><li><p> 资产是能把钱放进我口袋里的东西。负债是把钱从我口袋里取走的东西。</p></li><li><p> 如果你想富有，就必须读懂并理解那些数字。</p></li><li><p> 据说，对很多人来说在公众面前讲话比死还可怕。精神病学认为，害怕在公众面前说话是因为害怕被排斥、害怕冒尖、害怕被批评、害怕被嘲笑、害怕被别人所不容。简言之，是害怕与别人不同。这种心理阻碍了人们去想新办法来解决问题。</p></li></ul><h3 id="第三课-关注自己的事业"><a href="#第三课-关注自己的事业" class="headerlink" title="第三课 关注自己的事业"></a>第三课 关注自己的事业</h3><ul><li><p> ●不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了。<br>●股票<br>●债券<br>●能够产生收入的房地产<br>●票据（借据）<br>●版税，如音乐、手稿、专利<br>●其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西</p></li><li><p> 真正的奢侈品是对投资和积累真正资产的奖励。</p></li></ul><h3 id="讨论学习环节-1"><a href="#讨论学习环节-1" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li><p> 关注自己的事业。不要耗费一生为别人工作。</p></li><li><p> 关注自己的事业并不意味着要开一个公司，虽然有些人会这样。你的事业的重心应该是你的资产项，而不是你的收入项。</p></li><li><p> 左脑时刻：当资产产生的收入能够支付奢侈品时，才是你可以购买它们的时候。右脑时刻：创造性地去想一想什么才是你的事业，而不是你的职业。潜意识时刻：获取你所喜欢的资产，这样你才能很好地打理它们，享受其中的学习过程。</p></li><li><p> 一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买奢侈品。穷人和中产阶级用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品</p></li></ul><h3 id="第四课-税收的历史和公司的力量"><a href="#第四课-税收的历史和公司的力量" class="headerlink" title="第四课 税收的历史和公司的力量"></a>第四课 税收的历史和公司的力量</h3><ul><li><p> 斗争会永远持续下去，吃亏的人一定是无知者，即那些每天起来勤奋工作去付税的人。</p></li><li><p> 知识就是力量，而且钱越多，就越需要知识管理它，使它继续增加。</p></li><li><p> 我提醒人们，财商是由4个方面的专门知识构成的：1．会计会计就是财务知识或解读数字的能力。如果你想建立一个自己的商业帝国，财务知识是非常重要的。你管理的钱越多，就越要精确，否则这幢大厦就会倒塌。这需要左脑来处理，是细节的部分。财务知识能帮助你读懂财务报表，还能让你辨别一项生意的优势和劣势。2．投资投资是钱生钱的科学。投资涉及策略和方案，这要右脑来做，是属于创造的部分。3．了解市场了解市场是供给与需求的科学。这要求了解受感情驱动的市场的“技术面”。市场的另一个因素是“基本面”，或者说是一项投资的经济意义。一项投资究竟有无意义最终取决于当前的市场状况。4．法律利用一个具有会计、投资和市场运营的企业会使你的财富实现爆炸性地增长。了解减税优惠政策和公司法的人会比雇员和小业主更快致富。这就像一个人在走，而另一个人却在飞，久而久之这种差距就更大了。</p></li></ul><h3 id="讨论学习环节-2"><a href="#讨论学习环节-2" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li><p> 让罗伯特这一切变为可能的是财商，或者叫财务知识。它由4部分组成：会计（财务知识，也就是解读数字的能力以及评估一项生意的优势和劣势）、投资（钱生钱的科学和策略）、了解市场（供给与需求的科学以及市场条件）、法律（减税优惠和在诉讼中获得保护）。</p></li><li><p> 雇员挣钱、纳税，并靠剩下的钱为生；企业挣钱、花钱，并只为剩下来的钱缴税。这是富人钻的最大的法律空子。</p></li></ul><h3 id="第五课-富人的投资"><a href="#第五课-富人的投资" class="headerlink" title="第五课 富人的投资"></a>第五课 富人的投资</h3><ul><li><p> 玩《富爸爸现金流》游戏，上<a href="http://www.richdad.com,了解金钱运作的秘密./">www.richdad.com，了解金钱运作的秘密。</a></p></li><li><p> 我们唯一的，也是最重要的资产是我们的头脑。如果受到良好的训练，它就能创造大量的财富。</p></li><li><p> 如果你清楚自己在做什么，就不是在赌博；如果你把钱投进一笔交易然后只是祈祷，才是在赌博。</p></li><li><p> 好机会是用你的脑子而不是用你的眼睛看到的。</p></li></ul><h3 id="讨论学习环节-3"><a href="#讨论学习环节-3" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li><p> 如果你想成为第二种投资者，你就必须提升3种主要技能：第一，如何找到别人错失的机会；第二，如何筹集资金；第三，如何把精明的人组织起来并雇佣他们为你工作。风险无处不在，要学会驾驭风险，别总想回避风险。</p></li><li><p> 潜意识时刻：我们都拥有巨大的潜能——这是上天赏赐的礼物。我们都或多或少地存在着某种自我怀疑的心理，从而阻碍前进的步伐。这种障碍很少是缺乏某种技术性的东西，更多的是缺乏自信。</p></li></ul><h3 id="第六课-学会不为钱工作"><a href="#第六课-学会不为钱工作" class="headerlink" title="第六课 学会不为钱工作"></a>第六课 学会不为钱工作</h3><ul><li><p> 大多数教师缺乏现实世界的体验——他们没有做过他们所教授的事情。事实上，他们没有经历过他们在课堂上所教导的事情，也未尝试过犯错误，更不会从这些错误中学到东西，并把学到的东西应用在接下来的实践中，从而变得越来越好。学校教我们阅读和记忆。</p></li><li><p> “对许多知识，你只需知道一点就够了。”这是富爸爸给我的建议。</p></li><li><p> 还有另外一种可怕的管理理论是这样说的：“工人付出最大努力以免于被解雇，而雇主提供最低工资以防止工人辞职。”</p></li><li><p> 成功所必需的管理技能包括：<br>1．对现金流的管理。<br>2．对系统的管理。<br>3．对人员的管理。</p></li><li><p> 最重要的专门技能是销售和对市场营销的理解。销售技能是个人成功的基本技能，它涉及与其他人的交往，包括与顾客、雇员、老板、配偶和孩子。而沟通能力，如书面表达、口头表达及谈判能力等对一个人的成功来说更是至关重要。我就是通过学习各种课程、听教学磁带等来扩展知识并不断提高自己的这一技能的。</p></li><li><p> 付出金钱是那些非常富有的家庭保持富有的秘诀</p></li><li><p> 他更加努力地工作以增加收入，却没有注意到一条最重要的金钱法则——给予，然后获得。相反，他信奉的是“得到后再付出”。</p></li></ul><h3 id="讨论学习环节-4"><a href="#讨论学习环节-4" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li><p> 罗伯特建议人们要有长远眼光：不要单纯地为了赚钱和安稳而工作，应当再找一份工作，并从中学习另一种技能。</p></li><li><p> 如果你坚持不愿意学习新东西，而只是想在自己的领域里成为专家，那么你要确信你服务的公司是有工会的，因为工会会保护专业人士。否则在你的专业之外，你的专业技能可能一无是处。</p></li><li><p> 成功所必需的管理技能包括：（1）现金流管理；（2）系统管理；（3）人员管理。最重要的专业技能是销售技能和营销技能。沟通能力，如书面表达、口头表达及谈判能力等对一个人的成功来说更是至关重要。</p></li><li><p> 要想真正富有，我们既要不吝付出也要学会索取。</p></li><li><p> 工作（job）一词就是‘比破产强一点’（just over broke）</p></li></ul><h3 id="克服困难"><a href="#克服困难" class="headerlink" title="克服困难"></a>克服困难</h3><ul><li><p> 对大多数人来说，他们在财务上不成功是因为对他们而言亏钱所造成的痛苦远远大于致富所带来的乐趣。</p></li><li><p> 失败会激励胜利者，击垮失败者。</p></li><li><p> 让我们重复一遍弗朗·塔肯顿的话：“胜利意味着不害怕失败。”</p></li><li><p> 大部分人之所以贫穷，是因为在他们想要投资的时候，周围到处是跑来跑去的“小鸡”，叫嚷着“天要塌下来了，天要塌下来了”。“小鸡”们的说法很有影响力，因为我们每个人的心中也都有一只“小鸡”。因此，我们常常需要极大的勇气，不让谣言和杞人忧天的怀疑加剧我们的恐惧和疑虑。</p></li><li><p> “愤世者永远不会成功。”富爸爸说。“未经证实的怀疑和恐惧会使人们成为愤世嫉俗者。愤世者抱怨现实，而成功者分析现实。”</p></li><li><p> 富爸爸解释，抱怨蒙蔽人的头脑，而分析使人心明眼亮。通过分析能使成功者看到那些愤世者无法看到的东西，发现被其他人都忽视的机会，而发现机会的能力正是取得成功的关键。</p></li><li><p> 我经常遇到那些过分忙于工作而不关心自己的财富的人。还有一些人过分地忙于工作而不照顾自己的身体。使这两种人如此忙碌的原因是一样的，他们把忙碌作为逃避问题的借口。没有人告诉他们这些，但他们心里其实很明白。事实上，如果你去提醒他们，他们往往还会很不高兴。</p></li><li><p> 这是懒惰最普遍的表现形式，一种通过忙碌掩饰下的懒惰。</p></li><li><p> 然而，我们的心里都渴望拥有那些美好、新颖和令人兴奋的东西。因此，父母就常常利用负罪感来抑制这种欲望</p></li><li><p> 富爸爸相信“我可付不起”这句话禁锢了你的思想，使你无法进一步思考。“我怎样才能付得起”这句话则开启了你的头脑，迫使你去思考并寻求答案。</p></li><li><p> 临走时他带着自我牺牲的骄傲神情对我说。</p></li><li><p> 当然，就像任何事情都要有“度”一样，过于贪婪就不好了。但要记住迈克尔·道格拉斯在电影《华尔街》中说的话：“欲望是好事。”富爸爸用另一种方式进行解释：“负罪感比欲望要糟，因为负罪感抢走了灵魂。”对我来说，埃莉诺·罗斯福说的最好：“做你内心认为正确的事情因为你不管怎么做总会受到批评。如果你做，会受到指责；而你不做，还是会受到指责。”</p></li></ul><h3 id="讨论学习环节-5"><a href="#讨论学习环节-5" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li><p> 但掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：（1）恐惧；（2）愤世嫉俗；（3）懒惰；（4）不良习惯；（5）自负。让我们来详细分析每种情况。</p></li><li><p> 懒惰最常见的形式之一是忙碌掩饰之下的懒惰。</p></li></ul><h3 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h3><ul><li><p> 金矿到处都是，但大部分人没有经过相应的培训，所以发现不了它们。</p></li><li><p> 1．找一个超现实的理由——精神的力量</p></li><li><p> 些说法存在着一个共同的问题，就是它们阻碍人们去思考这样两件事情：第一是时间，这是你最珍贵的资产；第二是学习，正因为你没有钱，就更要去学习。事实上我们每天都应该做出一个选择，这个选择是我们利用自己的时间、金钱和头脑里学到的东西做出的。这就是选择的力量。我们都有机会。我选择成为富人，每天都在为此而努力。</p></li><li><p> 首先投资于教育。实际上，你所拥有的唯一真正的资产就是你的头脑，这是我们能控制的最强有力的工具。</p></li><li><p> 骄傲自大或吹毛求疵的人往往是缺乏自信而不敢冒险的人</p></li><li><p> 一个真正聪明的人总是欢迎新思想，因为新思想能使他的思想库更加丰富。听比说更重要，否则，上帝就不会给我们两只耳朵一张嘴巴了。</p></li><li><p> 能否自律是将富人、穷人和中产阶级区分开来的首要因素。</p></li><li><p> 生活推着你转。生活之所以能推着你转，不是因为生活的力量很强大，而是因为你缺乏自律。那些不够坚毅的人往往会成为那些自律性很强的人的手下败将。</p></li><li><p> 在我教过的企业家培训班中，我经常提醒人们，不要仅将注意力集中在产品、服务或生产设备上，而要集中精力开发管理才能。开创事业所必备的最重要的3种管理技能是：</p></li></ul><p>1．现金流管理。<br>2．人事管理。<br>3．个人时间管理。</p><ul><li><p> 不是说要人们不负责任、不付账单，我的意思只是要像那本书所说的那样：“首先支付自己。</p></li><li><p> 这本书的真正目的是要告诉你：有胆量不随大流才能致富。你也许并不软弱，但一旦涉及金钱，往往会变得怯懦。</p></li><li><p> 为了能更好地做到“首先支付自己”，请谨记以下两点：<br>1．不要背上数额过大的债务包袱。要保持低支出。首先增加自己的资产，然后，再用资产项产生的现金流来买大房子或豪车。陷在“老鼠赛跑”中不是明智的选择。<br>2．当你资金短缺时，让压力去发挥作用，而不要动用你的储蓄或资本。利用这种压力来激发你的理财天赋，想出新办法挣到更多的钱，然后再支付账单。这样做，不但能让你赚到钱，还能提高你的财商。</p></li><li><p> 穷人有一些不好的习惯，其中一个普遍的坏习惯就是随便动用储蓄。富人知道储蓄只能用于创造更多的收入，而不是用来支付账单。</p></li><li><p> 经纪人是我在市场上的“眼睛”和“耳朵”，他们代替我整天密切地注视着市场动向，而我可以去打高尔夫球。</p></li><li><p> 因为从理论上来讲，从一项资产中获得现金流的过程是容易的，但是拥有正确的支配金钱的坚强意志却是困难的。在今天的消费者世界里，由于种种外在的诱惑，所以很容易在支出项上挥霍金钱。因为意志薄弱，金钱的流出简直是无遮无拦，这就是大多数人贫困并在财务困境中苦苦挣扎的原因。</p></li><li><p> 记住，轻松的道路往往会越走越艰难，而艰难的道路往往会越走越轻松。</p></li><li><p> 要成为金钱的主人，你就要比金钱更精明。然后金钱才能按照你的要求办事，它会屈服于你，这样你就是它的主人，而不是它的奴隶。这就是财商。</p></li><li><p> 在市场上或为交易进行谈判时，我下意识地模仿特朗普的那种气势和自信；当分析某种趋势时，我学着像沃伦·巴菲特那样思考。通过偶像的模范作用，我们挖掘出自身的巨大潜能。</p></li><li><p> 在投资问题上，许多人总是说有多么多么困难，而不去找能够“帮助”他们的英雄。</p></li><li><p> 当你感到手头“有点紧”或是想得到什么时，首先要想到给予，只有先“予”，你才能在将来取得丰厚的回报，无论金钱、微笑、爱情还是友谊都是如此。</p></li><li><p> 的确，你的世界就是你的一面镜子。</p></li></ul><h3 id="讨论学习环节-6"><a href="#讨论学习环节-6" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li><p> 多听，多学习。以长远的眼光来看待财富，不要存有一夜暴富的念头。在投资股票或房地产之前，请先投资你最重要的资产——头脑。</p></li><li><p> 掌握一种模式，然后再学习一种新的模式——快速学习的力量</p></li><li><p> 开创事业所必备的最重要的3种管理技能是分别是：现金流管理、人事管理和个人时间管理。这3项管理技能适用于每个人，不仅仅对企业家而言，并且每一项技能都可以通过自律来增强。</p></li><li><p> 1．不要让自己背上数额过大的债务包袱。保持低支出。首先建立资产项，然后再用资产项购买大房子或豪车。<br>2．当你资金短缺时，让压力去发挥作用，不要动用你的储蓄或投资。利用压力激发你的理财天赋，想出新的赚钱方法，然后支付你的账单。这样不但能让你赚到钱，还能提高你的财商。</p></li><li><p> 致富，并不以牺牲舒适为代价的方式支付账单。</p></li><li><p> 增加资产以支付自己想要的东西。</p></li><li><p> 轻松的道路往往会越走越艰难，而艰难的道路往往会越走越轻松。</p></li></ul><h3 id="还想要更多吗？这里有一些要做的事情"><a href="#还想要更多吗？这里有一些要做的事情" class="headerlink" title="还想要更多吗？这里有一些要做的事情"></a>还想要更多吗？这里有一些要做的事情</h3><ul><li><p> 寻找一桩好生意、一家好企业、一位合适的人、一位合适的投资者，或任何类似的东西，就如同约会一样。你必须到市场上去和许多人谈，做许多报价、还价、谈判、拒绝或者接受。我知道有些单身的人宁可在家里坐等电话铃响，但是你最好还是到市场上去，即使只是一家超市也好。从寻找、报价、拒绝、谈判到成交，几乎是人的一生中要经历的全部过程。</p></li><li><p> 利润是买来的，而不是卖出来的。</p></li></ul><h3 id="讨论学习环节-7"><a href="#讨论学习环节-7" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li> 对于那些想要一份具体的行动指南清单的人来说，可参考以下罗伯特的做法。</li></ul><p>●停下你手头的活儿。休息一下，评估一下你的做法中哪些有效，哪些无效。<br>●寻找新的思想。到书店搜寻能提供独特、与众不同这类主张的书。乔尔·莫斯科维茨的《收益率达到16%的方法》这本书教会了罗伯特新的东西，并促使他采取行动。<br>●找一些做过你想做的事情的人。请他们和你一起共进午餐，向他们请教一些诀窍和技巧。<br>●参加辅导班、阅读和参加研讨会。罗伯特从报纸和互联网上搜索新的、有趣的课程。<br>●提出多份报价。你根本就不知道什么价格才是“合适”的，除非有另一处同样的交易作为参照。大部分卖主的要价过高，很少有要价低于标的物的实际价值。做买卖就是一场有趣的游戏。你提出报价之后，就会有人跟你达成购买意向。记得使用“免责条款”来做报价。<br>●每月在某一地区慢跑、散步或驾车10分钟左右。罗伯特在慢跑过程中发现了他投资中最好的房地产项目。他会常常固定在某一邻近的社区慢跑，为的是发现某些变化。一桩交易要赢利，必须具备两个条件：一是廉价，二是有变化。市场上有许多廉价交易，但只有存在变化，才能使廉价交易变得有利可图。这样做每月只需要花很少时间，同时还能做其他的事情，比如锻炼锻炼身体，或去商店走走看看等。<br>●为什么消费者总是穷人？每当超市大减价，如卫生纸打折时，消费者就会涌入超市抢购。而当股票市场上出现股价下跌时，也就是大多数人所说的股市下挫或回调时，购买者却急于从中逃出。记住：利润在购买时就已确定，而不是在出售时获得的。<br>●关注适当的地方。邻居以10万美元购买了一套公寓，罗伯特则以5万美元购买了与之相邻的、相同的一套公寓。邻居告诉罗伯特他在等着价格上涨。罗伯特对邻居说他能获得的利润在他购买这套公寓时就已经确定了，而并不是在他出售时确定的。邻居是通过一位房地产经纪人来进行这笔交易的，而这位经纪人却并没有属于自己的房产。罗伯特则是在一家银行的破产清偿部购买的。罗伯特曾花500美元参加了一个学习班，学习如何在破产清偿部购买这类房产。<br>他的这位邻居认为花500美元上一个学习班未免太贵了，还说自己没有钱，也没有时间，所以只能寄希望于价格上升。<br>●首先寻找想买进的人，然后才去找想卖出的人。买下一大块馅饼并把它切成小块。大部分人寻找的只是自己能付得起的东西，所以他们只看到较小的东西。他们只买一小块馅饼，却总是付出更高的价格。只盯着小生意的人是不会有大突破的。你如果想致富，就要首先考虑较大的生意。<br>●考虑大生意。零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。所以即使你的投资规模很小，你也可以多考虑考虑大生意。小规模投资人善于小规模的动作，因为他们思考的范围太狭窄，他们总是单干，从不协同作战。<br>●学习前人经验。所有上市的大公司都是从小公司起家的。桑德斯上校在60多岁失去了所有财产之后才致富。比尔·盖茨在30岁以前就成了世界上最富有的人之一。<br>●行动的人总会击败不行动的人。在你得到财富的回报以前必须先行动。那么现在就行动吧！</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><ul><li><p> 变富有的关键是拥有尽快将劳动性收入转换成被动收入或投资组合收入的能力。</p></li><li><p> 劳动性收入的税赋是最重的，而税赋最轻的收入则是被动收入。这也是为什么你要让金钱为你努力工作的另一个原因。政府从你努力工作所得的收入中收的税比你的金钱为你努力工作所得的收入所收的税还高。</p></li><li><p> 实现财务自由和获得巨大财富的关键取决于一个人将劳动性收入转化成被动收入或投资组合收入的能力。</p></li><li><p> 正如富爸爸所说：“真正的投资者在市场上涨和下跌时都能赚钱。他们能赚更多钱的原因之一仅仅是因为他们拥有更多的自信。他们拥有更多的自信是因为他们没那么害怕失败。”换句话说，普通投资者赚不了那么多钱是因为他们非常害怕赔钱</p></li><li><p> 正如美国最富有的投资者沃伦·巴菲特说的“风险来自于你不知道自己在做什么”。</p></li><li><p> 上天赐予我们每个人两样伟大的礼物：思想和时间。你可以运用这两件礼物去做你愿意做的事情。每一美元钞票到了你的手中，你，且只有你，才有权决定自己的前途。</p></li></ul><h3 id="讨论学习环节-8"><a href="#讨论学习环节-8" class="headerlink" title="讨论学习环节"></a>讨论学习环节</h3><ul><li><p> 在会计领域，有三种收入：劳动性收入、投资组合收入和被动收入。在大多数情况下，被动收入多来自房地产投资，投资组合收入一般来自股票和债券等纸质资产投资。</p></li><li><p> 上天赐予我们每个人两样伟大的礼物：思想和时间。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
